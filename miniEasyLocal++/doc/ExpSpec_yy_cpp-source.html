<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <title>EasyLocal++ Documentation</title>
  <link href="local.css" rel="stylesheet" type="text/css">
</head>

<body lang="en">

<table width="100%" border="0">
  <tbody>
    <tr>
      <td colspan="2"><h1 class="nojustify">EasyLocal++ Documentation</h1>
        <hr>
      </td>
    </tr>
    <tr>
      <td width="30" align="center">&nbsp;</td>
      <td>
<!-- Generated by Doxygen 1.2.5 on Sat Jun 9 14:57:32 2001 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>ExpSpec.yy.cpp</h1><div class="fragment"><pre>00001 <font class="preprocessor">#line 2 "ExpSpec.yy.cpp"</font>
00002 <font class="preprocessor"></font><font class="comment">/* A lexical scanner generated by flex */</font>
00003 
00004 <font class="comment">/* Scanner skeleton version:</font>
00005 <font class="comment"> * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $</font>
00006 <font class="comment"> */</font>
00007 
00008 <font class="preprocessor">#define FLEX_SCANNER</font>
00009 <font class="preprocessor"></font><font class="preprocessor">#define YY_FLEX_MAJOR_VERSION 2</font>
00010 <font class="preprocessor"></font><font class="preprocessor">#define YY_FLEX_MINOR_VERSION 5</font>
00011 <font class="preprocessor"></font>
00012 <font class="preprocessor">#include &lt;stdio.h&gt;</font>
00013 
00014 
00015 <font class="comment">/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */</font>
00016 <font class="preprocessor">#ifdef c_plusplus</font>
00017 <font class="preprocessor"></font><font class="preprocessor">#ifndef __cplusplus</font>
00018 <font class="preprocessor"></font><font class="preprocessor">#define __cplusplus</font>
00019 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00020 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00021 <font class="preprocessor"></font>
00022 
00023 <font class="preprocessor">#ifdef __cplusplus</font>
00024 <font class="preprocessor"></font>
00025 <font class="preprocessor">#include &lt;stdlib.h&gt;</font>
00026 <font class="preprocessor">#include &lt;unistd.h&gt;</font>
00027 
00028 <font class="comment">/* Use prototypes in function declarations. */</font>
00029 <font class="preprocessor">#define YY_USE_PROTOS</font>
00030 <font class="preprocessor"></font>
00031 <font class="comment">/* The "const" storage-class-modifier is valid. */</font>
00032 <font class="preprocessor">#define YY_USE_CONST</font>
00033 <font class="preprocessor"></font>
00034 <font class="preprocessor">#else   </font><font class="comment">/* ! __cplusplus */</font>
00035 
00036 <font class="preprocessor">#if __STDC__</font>
00037 <font class="preprocessor"></font>
00038 <font class="preprocessor">#define YY_USE_PROTOS</font>
00039 <font class="preprocessor"></font><font class="preprocessor">#define YY_USE_CONST</font>
00040 <font class="preprocessor"></font>
00041 <font class="preprocessor">#endif  </font><font class="comment">/* __STDC__ */</font>
00042 <font class="preprocessor">#endif  </font><font class="comment">/* ! __cplusplus */</font>
00043 
00044 <font class="preprocessor">#ifdef __TURBOC__</font>
00045 <font class="preprocessor"></font><font class="preprocessor"> #pragma warn -rch</font>
00046 <font class="preprocessor"></font><font class="preprocessor"> #pragma warn -use</font>
00047 <font class="preprocessor"></font><font class="preprocessor">#include &lt;io.h&gt;</font>
00048 <font class="preprocessor">#include &lt;stdlib.h&gt;</font>
00049 <font class="preprocessor">#define YY_USE_CONST</font>
00050 <font class="preprocessor"></font><font class="preprocessor">#define YY_USE_PROTOS</font>
00051 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00052 <font class="preprocessor"></font>
00053 <font class="preprocessor">#ifdef YY_USE_CONST</font>
00054 <font class="preprocessor"></font><font class="preprocessor">#define yyconst const</font>
00055 <font class="preprocessor"></font><font class="preprocessor">#else</font>
00056 <font class="preprocessor"></font><font class="preprocessor">#define yyconst</font>
00057 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00058 <font class="preprocessor"></font>
00059 
00060 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
00061 <font class="preprocessor"></font><font class="preprocessor">#define YY_PROTO(proto) proto</font>
00062 <font class="preprocessor"></font><font class="preprocessor">#else</font>
00063 <font class="preprocessor"></font><font class="preprocessor">#define YY_PROTO(proto) ()</font>
00064 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00065 <font class="preprocessor"></font>
00066 <font class="comment">/* Returned upon end-of-file. */</font>
00067 <font class="preprocessor">#define YY_NULL 0</font>
00068 <font class="preprocessor"></font>
00069 <font class="comment">/* Promotes a possibly negative, possibly signed char to an unsigned</font>
00070 <font class="comment"> * integer for use as an array index.  If the signed char is negative,</font>
00071 <font class="comment"> * we want to instead treat it as an 8-bit unsigned char, hence the</font>
00072 <font class="comment"> * double cast.</font>
00073 <font class="comment"> */</font>
00074 <font class="preprocessor">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</font>
00075 <font class="preprocessor"></font>
00076 <font class="comment">/* Enter a start condition.  This macro really ought to take a parameter,</font>
00077 <font class="comment"> * but we do it the disgusting crufty way forced on us by the ()-less</font>
00078 <font class="comment"> * definition of BEGIN.</font>
00079 <font class="comment"> */</font>
00080 <font class="preprocessor">#define BEGIN yy_start = 1 + 2 *</font>
00081 <font class="preprocessor"></font>
00082 <font class="comment">/* Translate the current start state into a value that can be later handed</font>
00083 <font class="comment"> * to BEGIN to return to the state.  The YYSTATE alias is for lex</font>
00084 <font class="comment"> * compatibility.</font>
00085 <font class="comment"> */</font>
00086 <font class="preprocessor">#define YY_START ((yy_start - 1) / 2)</font>
00087 <font class="preprocessor"></font><font class="preprocessor">#define YYSTATE YY_START</font>
00088 <font class="preprocessor"></font>
00089 <font class="comment">/* Action number for EOF rule of a given start state. */</font>
00090 <font class="preprocessor">#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)</font>
00091 <font class="preprocessor"></font>
00092 <font class="comment">/* Special action meaning "start processing a new file". */</font>
00093 <font class="preprocessor">#define YY_NEW_FILE yyrestart( yyin )</font>
00094 <font class="preprocessor"></font>
00095 <font class="preprocessor">#define YY_END_OF_BUFFER_CHAR 0</font>
00096 <font class="preprocessor"></font>
00097 <font class="comment">/* Size of default input buffer. */</font>
00098 <font class="preprocessor">#define YY_BUF_SIZE 16384</font>
00099 <font class="preprocessor"></font>
00100 <font class="keyword">typedef</font> <font class="keyword">struct </font>yy_buffer_state *YY_BUFFER_STATE;
00101 
00102 <font class="keyword">extern</font> <font class="keywordtype">int</font> yyleng;
00103 <font class="keyword">extern</font> FILE *yyin, *yyout;
00104 
00105 <font class="preprocessor">#define EOB_ACT_CONTINUE_SCAN 0</font>
00106 <font class="preprocessor"></font><font class="preprocessor">#define EOB_ACT_END_OF_FILE 1</font>
00107 <font class="preprocessor"></font><font class="preprocessor">#define EOB_ACT_LAST_MATCH 2</font>
00108 <font class="preprocessor"></font>
00109 <font class="comment">/* The funky do-while in the following #define is used to turn the definition</font>
00110 <font class="comment"> * int a single C statement (which needs a semi-colon terminator).  This</font>
00111 <font class="comment"> * avoids problems with code like:</font>
00112 <font class="comment"> *</font>
00113 <font class="comment"> *      if ( condition_holds )</font>
00114 <font class="comment"> *              yyless( 5 );</font>
00115 <font class="comment"> *      else</font>
00116 <font class="comment"> *              do_something_else();</font>
00117 <font class="comment"> *</font>
00118 <font class="comment"> * Prior to using the do-while the compiler would get upset at the</font>
00119 <font class="comment"> * "else" because it interpreted the "if" statement as being all</font>
00120 <font class="comment"> * done when it reached the ';' after the yyless() call.</font>
00121 <font class="comment"> */</font>
00122 
00123 <font class="comment">/* Return all but the first 'n' matched characters back to the input stream. */</font>
00124 
00125 <font class="preprocessor">#define yyless(n) \</font>
00126 <font class="preprocessor">        do \</font>
00127 <font class="preprocessor">                { \</font>
00128 <font class="preprocessor">                </font><font class="comment">/* Undo effects of setting up yytext. */</font> \
00129                 *yy_cp = yy_hold_char; \
00130                 YY_RESTORE_YY_MORE_OFFSET \
00131                 yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
00132                 YY_DO_BEFORE_ACTION; <font class="comment">/* set up yytext again */</font> \
00133                 } \
00134         while ( 0 )
00135 
00136 <font class="preprocessor">#define unput(c) yyunput( c, yytext_ptr )</font>
00137 <font class="preprocessor"></font>
00138 <font class="comment">/* The following is because we cannot portably get our hands on size_t</font>
00139 <font class="comment"> * (without autoconf's help, which isn't available because we want</font>
00140 <font class="comment"> * flex-generated scanners to compile on their own).</font>
00141 <font class="comment"> */</font>
00142 <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> yy_size_t;
00143 
00144 
00145 <font class="keyword">struct </font>yy_buffer_state
00146         {
00147         FILE *yy_input_file;
00148 
00149         <font class="keywordtype">char</font> *yy_ch_buf;                <font class="comment">/* input buffer */</font>
00150         <font class="keywordtype">char</font> *yy_buf_pos;               <font class="comment">/* current position in input buffer */</font>
00151 
00152         <font class="comment">/* Size of input buffer in bytes, not including room for EOB</font>
00153 <font class="comment">         * characters.</font>
00154 <font class="comment">         */</font>
00155         yy_size_t yy_buf_size;
00156 
00157         <font class="comment">/* Number of characters read into yy_ch_buf, not including EOB</font>
00158 <font class="comment">         * characters.</font>
00159 <font class="comment">         */</font>
00160         <font class="keywordtype">int</font> yy_n_chars;
00161 
00162         <font class="comment">/* Whether we "own" the buffer - i.e., we know we created it,</font>
00163 <font class="comment">         * and can realloc() it to grow it, and should free() it to</font>
00164 <font class="comment">         * delete it.</font>
00165 <font class="comment">         */</font>
00166         <font class="keywordtype">int</font> yy_is_our_buffer;
00167 
00168         <font class="comment">/* Whether this is an "interactive" input source; if so, and</font>
00169 <font class="comment">         * if we're using stdio for input, then we want to use getc()</font>
00170 <font class="comment">         * instead of fread(), to make sure we stop fetching input after</font>
00171 <font class="comment">         * each newline.</font>
00172 <font class="comment">         */</font>
00173         <font class="keywordtype">int</font> yy_is_interactive;
00174 
00175         <font class="comment">/* Whether we're considered to be at the beginning of a line.</font>
00176 <font class="comment">         * If so, '^' rules will be active on the next match, otherwise</font>
00177 <font class="comment">         * not.</font>
00178 <font class="comment">         */</font>
00179         <font class="keywordtype">int</font> yy_at_bol;
00180 
00181         <font class="comment">/* Whether to try to fill the input buffer when we reach the</font>
00182 <font class="comment">         * end of it.</font>
00183 <font class="comment">         */</font>
00184         <font class="keywordtype">int</font> yy_fill_buffer;
00185 
00186         <font class="keywordtype">int</font> yy_buffer_status;
00187 <font class="preprocessor">#define YY_BUFFER_NEW 0</font>
00188 <font class="preprocessor"></font><font class="preprocessor">#define YY_BUFFER_NORMAL 1</font>
00189 <font class="preprocessor"></font>        <font class="comment">/* When an EOF's been seen but there's still some text to process</font>
00190 <font class="comment">         * then we mark the buffer as YY_EOF_PENDING, to indicate that we</font>
00191 <font class="comment">         * shouldn't try reading from the input source any more.  We might</font>
00192 <font class="comment">         * still have a bunch of tokens to match, though, because of</font>
00193 <font class="comment">         * possible backing-up.</font>
00194 <font class="comment">         *</font>
00195 <font class="comment">         * When we actually see the EOF, we change the status to "new"</font>
00196 <font class="comment">         * (via yyrestart()), so that the user can continue scanning by</font>
00197 <font class="comment">         * just pointing yyin at a new input file.</font>
00198 <font class="comment">         */</font>
00199 <font class="preprocessor">#define YY_BUFFER_EOF_PENDING 2</font>
00200 <font class="preprocessor"></font>        };
00201 
00202 <font class="keyword">static</font> YY_BUFFER_STATE yy_current_buffer = 0;
00203 
00204 <font class="comment">/* We provide macros for accessing buffer states in case in the</font>
00205 <font class="comment"> * future we want to put the buffer states in a more general</font>
00206 <font class="comment"> * "scanner state".</font>
00207 <font class="comment"> */</font>
00208 <font class="preprocessor">#define YY_CURRENT_BUFFER yy_current_buffer</font>
00209 <font class="preprocessor"></font>
00210 
00211 <font class="comment">/* yy_hold_char holds the character lost when yytext is formed. */</font>
00212 <font class="keyword">static</font> <font class="keywordtype">char</font> yy_hold_char;
00213 
00214 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_n_chars;          <font class="comment">/* number of characters read into yy_ch_buf */</font>
00215 
00216 
00217 <font class="keywordtype">int</font> yyleng;
00218 
00219 <font class="comment">/* Points to current character in buffer. */</font>
00220 <font class="keyword">static</font> <font class="keywordtype">char</font> *yy_c_buf_p = (<font class="keywordtype">char</font> *) 0;
00221 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_init = 1;         <font class="comment">/* whether we need to initialize */</font>
00222 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_start = 0;        <font class="comment">/* start state number */</font>
00223 
00224 <font class="comment">/* Flag which is used to allow yywrap()'s to do buffer switches</font>
00225 <font class="comment"> * instead of setting up a fresh yyin.  A bit of a hack ...</font>
00226 <font class="comment"> */</font>
00227 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_did_buffer_switch_on_eof;
00228 
00229 <font class="keywordtype">void</font> yyrestart YY_PROTO(( FILE *input_file ));
00230 
00231 <font class="keywordtype">void</font> yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
00232 <font class="keywordtype">void</font> yy_load_buffer_state YY_PROTO(( <font class="keywordtype">void</font> ));
00233 YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, <font class="keywordtype">int</font> size ));
00234 <font class="keywordtype">void</font> yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
00235 <font class="keywordtype">void</font> yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
00236 <font class="keywordtype">void</font> yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
00237 <font class="preprocessor">#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )</font>
00238 <font class="preprocessor"></font>
00239 YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( <font class="keywordtype">char</font> *base, yy_size_t size ));
00240 YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst <font class="keywordtype">char</font> *yy_str ));
00241 YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst <font class="keywordtype">char</font> *bytes, <font class="keywordtype">int</font> len ));
00242 
00243 <font class="keyword">static</font> <font class="keywordtype">void</font> *yy_flex_alloc YY_PROTO(( yy_size_t ));
00244 <font class="keyword">static</font> <font class="keywordtype">void</font> *yy_flex_realloc YY_PROTO(( <font class="keywordtype">void</font> *, yy_size_t ));
00245 <font class="keyword">static</font> <font class="keywordtype">void</font> yy_flex_free YY_PROTO(( <font class="keywordtype">void</font> * ));
00246 
00247 <font class="preprocessor">#define yy_new_buffer yy_create_buffer</font>
00248 <font class="preprocessor"></font>
00249 <font class="preprocessor">#define yy_set_interactive(is_interactive) \</font>
00250 <font class="preprocessor">        { \</font>
00251 <font class="preprocessor">        if ( ! yy_current_buffer ) \</font>
00252 <font class="preprocessor">                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \</font>
00253 <font class="preprocessor">        yy_current_buffer-&gt;yy_is_interactive = is_interactive; \</font>
00254 <font class="preprocessor">        }</font>
00255 <font class="preprocessor"></font>
00256 <font class="preprocessor">#define yy_set_bol(at_bol) \</font>
00257 <font class="preprocessor">        { \</font>
00258 <font class="preprocessor">        if ( ! yy_current_buffer ) \</font>
00259 <font class="preprocessor">                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \</font>
00260 <font class="preprocessor">        yy_current_buffer-&gt;yy_at_bol = at_bol; \</font>
00261 <font class="preprocessor">        }</font>
00262 <font class="preprocessor"></font>
00263 <font class="preprocessor">#define YY_AT_BOL() (yy_current_buffer-&gt;yy_at_bol)</font>
00264 <font class="preprocessor"></font>
00265 
00266 <font class="preprocessor">#define YY_USES_REJECT</font>
00267 <font class="preprocessor"></font>
00268 <font class="preprocessor">#define yywrap() 1</font>
00269 <font class="preprocessor"></font><font class="preprocessor">#define YY_SKIP_YYWRAP</font>
00270 <font class="preprocessor"></font><font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> YY_CHAR;
00271 FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
00272 <font class="keyword">typedef</font> <font class="keywordtype">int</font> yy_state_type;
00273 <font class="keyword">extern</font> <font class="keywordtype">int</font> yylineno;
00274 <font class="keywordtype">int</font> yylineno = 1;
00275 <font class="keyword">extern</font> <font class="keywordtype">char</font> *yytext;
00276 <font class="preprocessor">#define yytext_ptr yytext</font>
00277 <font class="preprocessor"></font>
00278 <font class="keyword">static</font> yy_state_type yy_get_previous_state YY_PROTO(( <font class="keywordtype">void</font> ));
00279 <font class="keyword">static</font> yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
00280 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_get_next_buffer YY_PROTO(( <font class="keywordtype">void</font> ));
00281 <font class="keyword">static</font> <font class="keywordtype">void</font> yy_fatal_error YY_PROTO(( yyconst <font class="keywordtype">char</font> msg[] ));
00282 
00283 <font class="comment">/* Done after the current pattern has been matched and before the</font>
00284 <font class="comment"> * corresponding action - sets up yytext.</font>
00285 <font class="comment"> */</font>
00286 <font class="preprocessor">#define YY_DO_BEFORE_ACTION \</font>
00287 <font class="preprocessor">        yytext_ptr = yy_bp; \</font>
00288 <font class="preprocessor">        yyleng = (int) (yy_cp - yy_bp); \</font>
00289 <font class="preprocessor">        yy_hold_char = *yy_cp; \</font>
00290 <font class="preprocessor">        *yy_cp = '\0'; \</font>
00291 <font class="preprocessor">        yy_c_buf_p = yy_cp;</font>
00292 <font class="preprocessor"></font>
00293 <font class="preprocessor">#define YY_NUM_RULES 33</font>
00294 <font class="preprocessor"></font><font class="preprocessor">#define YY_END_OF_BUFFER 34</font>
00295 <font class="preprocessor"></font><font class="keyword">static</font> yyconst <font class="keywordtype">short</font> <font class="keywordtype">int</font> yy_acclist[214] =
00296     {   0,
00297         2,    2,   34,   32,   33,   30,   32,   33,   31,   33,
00298        29,   32,   33,   32,   33,   32,   33,   32,   33,   26,
00299        32,   33,   24,   32,   33,   28,   32,   33,   28,   32,
00300        33,   23,   32,   33,   28,   32,   33,   28,   32,   33,
00301        28,   32,   33,   28,   32,   33,   28,   32,   33,   11,
00302        32,   33,   28,   32,   33,   28,   32,   33,   28,   32,
00303        33,   28,   32,   33,   28,   32,   33,   28,   32,   33,
00304        22,   32,   33,    2,   32,   33,    2,   30,   32,   33,
00305         2,   29,   32,   33,    2,   32,   33,    3,   32,   33,
00306         2,   32,   33,    2,   32,   33,    2,   26,   32,   33,
00307 
00308         2,   24,   32,   33,    2,   28,   32,   33,    2,   23,
00309        32,   33,   27,    1,   26,   28,   28,   28,   28,   28,
00310        28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
00311        28,    2,    2,    3,    3,    4,    2,   27,    2,    2,
00312        26,    2,   28,    2,   28,   25,   28,   28,   28,   28,
00313        28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
00314         2,   25,   28,   28,   28,   28,   28,   28,   28,   28,
00315        28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
00316        28,   28,   28,   10,   28,   28,   28,   28,   28,   28,
00317         9,   28,   28,   28,    5,   28,   28,   28,    6,   28,
00318 
00319        28,   13,    8,   20,   12,    7,   15,   17,   18,   21,
00320        19,   16,   14
00321     } ;
00322 
00323 <font class="keyword">static</font> yyconst <font class="keywordtype">short</font> <font class="keywordtype">int</font> yy_accept[257] =
00324     {   0,
00325         1,    1,    1,    1,    1,    1,    1,    2,    3,    4,
00326         6,    9,   11,   14,   16,   18,   20,   23,   26,   29,
00327        32,   35,   38,   41,   44,   47,   50,   53,   56,   59,
00328        62,   65,   68,   71,   74,   77,   81,   85,   88,   91,
00329        94,   97,  101,  105,  109,  113,  113,  114,  115,  115,
00330       116,  117,  118,  119,  120,  121,  122,  123,  124,  125,
00331       126,  127,  128,  129,  130,  131,  132,  133,  134,  135,
00332       136,  137,  139,  140,  142,  144,  146,  147,  148,  149,
00333       150,  151,  152,  153,  154,  155,  156,  157,  158,  159,
00334       160,  161,  163,  164,  164,  165,  166,  167,  168,  169,
00335 
00336       170,  170,  170,  171,  172,  173,  174,  175,  175,  176,
00337       176,  177,  178,  179,  179,  179,  179,  179,  180,  181,
00338       182,  182,  183,  183,  184,  184,  186,  187,  188,  188,
00339       188,  188,  188,  188,  189,  190,  190,  190,  191,  191,
00340       191,  191,  192,  193,  193,  193,  193,  193,  193,  194,
00341       195,  195,  195,  197,  197,  197,  197,  197,  197,  197,
00342       197,  197,  197,  198,  199,  199,  199,  200,  200,  200,
00343       200,  200,  200,  200,  200,  200,  201,  202,  202,  202,
00344       202,  202,  202,  202,  202,  202,  202,  202,  202,  202,
00345       202,  202,  202,  202,  202,  202,  202,  202,  202,  202,
00346 
00347       202,  202,  202,  203,  203,  204,  204,  204,  204,  204,
00348       204,  204,  204,  204,  204,  204,  205,  206,  206,  206,
00349       206,  206,  206,  206,  206,  207,  207,  208,  208,  208,
00350       208,  208,  208,  208,  208,  208,  208,  208,  208,  208,
00351       209,  210,  210,  210,  210,  210,  210,  210,  210,  210,
00352       211,  211,  212,  213,  214,  214
00353     } ;
00354 
00355 <font class="keyword">static</font> yyconst <font class="keywordtype">int</font> yy_ec[256] =
00356     {   0,
00357         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
00358         1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
00359         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00360         1,    5,    1,    6,    1,    1,    1,    1,    1,    1,
00361         1,    7,    1,    1,    8,    9,   10,   11,   11,   11,
00362        11,   11,   11,   11,   11,   11,   11,   12,   13,    1,
00363         1,    1,    1,    1,   14,   14,   14,   14,   14,   14,
00364        14,   14,   15,   14,   14,   16,   14,   14,   17,   18,
00365        14,   19,   14,   20,   14,   14,   14,   14,   14,   14,
00366         1,    1,    1,    1,   21,    1,   22,   23,   24,   25,
00367 
00368        26,   27,   28,   29,   30,   14,   14,   31,   32,   33,
00369        34,   35,   14,   36,   37,   38,   39,   14,   14,   40,
00370        14,   14,   41,    1,   42,    1,    1,    1,    1,    1,
00371         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00372         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00373         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00374         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00375         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00376         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00377         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00378 
00379         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00380         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00381         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00382         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00383         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00384         1,    1,    1,    1,    1
00385     } ;
00386 
00387 <font class="keyword">static</font> yyconst <font class="keywordtype">int</font> yy_meta[43] =
00388     {   0,
00389         1,    1,    2,    1,    1,    3,    4,    5,    1,    1,
00390         5,    1,    1,    5,    5,    5,    5,    5,    5,    5,
00391         5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
00392         5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
00393         1,    1
00394     } ;
00395 
00396 <font class="keyword">static</font> yyconst <font class="keywordtype">short</font> <font class="keywordtype">int</font> yy_base[263] =
00397     {   0,
00398         0,    0,   28,   56,   84,  112,  154,  196,  446,  447,
00399       447,  447,  447,    0,  434,  437,   40,  447,  435,   44,
00400       447,   45,   42,   47,   46,   48,  447,   49,   50,   60,
00401        61,   56,   80,  447,    0,    0,    0,   53,   55,  431,
00402       434,   52,    0,  238,    0,  434,  428,  447,  427,   80,
00403       429,  428,   58,   84,   59,   85,   92,   88,   95,   93,
00404        97,   98,  102,   96,  101,  107,    0,  127,  104,  128,
00405       447,  424,  423,  131,  280,    0,  447,  131,  138,  112,
00406       140,  143,  160,  162,  163,  169,  175,  144,  145,  177,
00407       171,    0,  165,  406,  173,  181,  203,  183,  211,  210,
00408 
00409       186,  394,  220,  214,  182,  218,  219,  401,  217,  395,
00410       222,  184,  223,  405,  228,  406,  405,  246,  249,  227,
00411       389,  251,  394,  228,  388,  415,  252,  255,  391,  390,
00412       394,  396,  395,  253,  257,  379,  390,  265,  389,  379,
00413       387,  447,  262,  382,  385,  374,  370,  369,  226,  268,
00414       381,  384,  397,  392,  367,  375,  365,  368,  394,  376,
00415       392,  391,  260,  288,  363,  358,  447,  367,  362,  369,
00416       367,  359,  350,  349,  348,  269,  293,  350,  360,  356,
00417       342,  343,  350,  341,  348,  351,  350,  338,  352,  347,
00418       343,  341,  358,  343,  335,  341,  332,  332,  331,  341,
00419 
00420       329,  325,  447,  320,  447,  347,  330,  321,  323,  316,
00421       315,  321,  318,  327,  333,  447,  447,  322,  327,  300,
00422       298,  295,  303,  282,  447,  281,  447,  292,  291,  285,
00423       293,  275,  282,  299,  298,  283,  277,  271,  272,  447,
00424       447,  280,  274,  277,  269,  288,  266,  266,  260,  447,
00425       160,  447,  447,  447,  447,  322,  327,  102,  332,  337,
00426       342,  347
00427     } ;
00428 
00429 <font class="keyword">static</font> yyconst <font class="keywordtype">short</font> <font class="keywordtype">int</font> yy_def[263] =
00430     {   0,
00431       255,    1,    1,    1,    1,    1,  256,  256,  255,  255,
00432       255,  255,  255,  257,  255,  255,  255,  255,  258,  258,
00433       255,  258,  258,  258,  258,  258,  255,  258,  258,  258,
00434       258,  258,  258,  255,  259,  259,  259,  260,  261,  259,
00435       259,  259,  259,  262,  259,  257,  255,  255,  255,  255,
00436       258,  258,  258,  258,  258,  258,  258,  258,  258,  258,
00437       258,  258,  258,  258,  258,  258,  259,  260,  261,  261,
00438       255,  259,  259,  259,  262,   75,  255,  258,  258,  258,
00439       258,  258,  258,  258,  258,  258,  258,  258,  258,  258,
00440       258,  259,  258,  255,  258,  258,  258,  258,  258,  258,
00441 
00442       255,  255,  258,  258,  258,  258,  258,  255,  258,  255,
00443       258,  258,  258,  255,  255,  255,  255,  258,  258,  258,
00444       255,  258,  255,  258,  255,  258,  258,  258,  255,  255,
00445       255,  255,  255,  258,  258,  255,  255,  258,  255,  255,
00446       255,  255,  258,  255,  255,  255,  255,  255,  258,  258,
00447       255,  255,  258,  255,  255,  255,  255,  255,  255,  255,
00448       255,  255,  258,  258,  255,  255,  255,  255,  255,  255,
00449       255,  255,  255,  255,  255,  258,  258,  255,  255,  255,
00450       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00451       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00452 
00453       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00454       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00455       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00456       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00457       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00458       255,  255,  255,  255,    0,  255,  255,  255,  255,  255,
00459       255,  255
00460     } ;
00461 
00462 <font class="keyword">static</font> yyconst <font class="keywordtype">short</font> <font class="keywordtype">int</font> yy_nxt[490] =
00463     {   0,
00464        10,   11,   12,   13,   13,   14,   10,   10,   15,   16,
00465        17,   10,   18,   19,   20,   19,   19,   19,   19,   19,
00466        10,   19,   19,   19,   19,   19,   19,   19,   19,   19,
00467        19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
00468        21,   10,   19,   22,   23,   24,   25,   26,   49,   51,
00469        50,   51,   51,   51,   51,   51,   51,   51,   67,   46,
00470        73,   70,   74,   51,   71,   51,   51,   51,   51,   27,
00471        19,   22,   23,   24,   25,   26,   53,   56,   54,   60,
00472        55,   61,   59,   58,   57,   64,   63,   51,   49,   62,
00473        50,   51,   51,   65,   78,   51,   80,   27,   19,   51,
00474 
00475        51,   66,   51,   51,   51,   51,   52,   28,   51,   51,
00476       255,   79,   29,  255,   51,   30,   31,   83,   81,   51,
00477        32,   33,   90,   85,   82,   34,   19,   89,   84,   91,
00478        87,   88,   92,   46,   70,   28,   86,   71,   51,   73,
00479        29,   74,   94,   30,   31,   51,   95,   51,   32,   33,
00480        51,   51,   51,   34,   35,   36,   12,   37,   37,   38,
00481        39,   35,   40,   41,   42,   35,   43,   51,   93,   51,
00482        51,  103,   51,  101,   35,   97,   51,   96,   51,  102,
00483        51,   98,   51,  104,   51,  110,  107,  254,   51,   51,
00484        51,   51,   99,  100,   45,   35,   35,   36,   12,   37,
00485 
00486        37,   38,   39,   35,   40,   41,   42,   35,   43,  106,
00487        51,  109,  105,  112,  114,  115,   35,   51,   51,  120,
00488       127,   51,  121,  116,   51,   51,   51,   51,  111,   51,
00489        51,  136,  140,   51,   51,   51,   45,   35,   67,   67,
00490       113,   67,   67,   67,  119,   75,   67,   67,  118,   67,
00491        67,  122,  130,   51,  124,  128,   51,  126,   51,   51,
00492        51,  163,   51,  142,   51,  131,  157,   51,  134,   51,
00493       135,  253,   51,  188,  138,   51,   51,  252,   67,   67,
00494        67,   67,  143,   67,   67,   67,  149,   75,   67,   67,
00495       153,   67,   67,  164,  150,   51,  176,  189,  251,  250,
00496 
00497        51,  249,  248,  247,  246,  245,  244,  243,  242,  241,
00498       240,  239,  177,  238,  237,  236,  235,  234,  233,  232,
00499        67,   67,   44,   44,   44,   44,   44,   46,  231,  230,
00500        46,   46,   67,  229,   67,  228,   67,   68,  227,   68,
00501        68,   68,   69,  226,  225,   69,   69,   76,  224,   76,
00502       223,   76,  222,  221,  220,  219,  218,  217,  216,  215,
00503       214,  213,  212,  211,  210,  209,  208,  207,  206,  205,
00504       204,  203,  202,  201,  200,  199,  198,  197,  196,  195,
00505       194,  193,  192,  191,  190,  187,  186,  185,  184,  183,
00506       182,  181,  180,  179,  178,  175,  174,  173,  172,  171,
00507 
00508       170,  169,  168,  167,   51,  166,  165,  162,  161,  160,
00509       159,  158,  156,  155,  154,  152,  151,  148,  147,  146,
00510       145,  144,   51,  141,  139,  137,  133,  132,  129,  125,
00511       123,  117,  108,   72,   72,   51,   51,   47,   47,   77,
00512        48,   72,   51,   48,   47,  255,    9,  255,  255,  255,
00513       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00514       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00515       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00516       255,  255,  255,  255,  255,  255,  255,  255,  255
00517     } ;
00518 
00519 <font class="keyword">static</font> yyconst <font class="keywordtype">short</font> <font class="keywordtype">int</font> yy_chk[490] =
00520     {   0,
00521         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00522         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00523         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00524         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00525         1,    1,    3,    3,    3,    3,    3,    3,   17,   23,
00526        17,   20,   22,   25,   24,   26,   28,   29,   38,   38,
00527        42,   39,   42,   32,   39,   53,   55,   30,   31,    3,
00528         4,    4,    4,    4,    4,    4,   20,   24,   22,   29,
00529        23,   30,   28,   26,   25,   32,   31,   33,   50,   30,
00530        50,   54,   56,   32,   53,   58,   55,    4,    5,   57,
00531 
00532        60,   33,   59,   64,   61,   62,  258,    5,   65,   63,
00533        69,   54,    5,   69,   66,    5,    5,   58,   56,   80,
00534         5,    5,   65,   60,   57,    5,    6,   64,   59,   66,
00535        62,   63,   68,   68,   70,    6,   61,   70,   78,   74,
00536         6,   74,   79,    6,    6,   79,   80,   81,    6,    6,
00537        82,   88,   89,    6,    7,    7,    7,    7,    7,    7,
00538         7,    7,    7,    7,    7,    7,    7,   83,   78,   84,
00539        85,   88,   93,   86,    7,   82,   86,   81,   91,   87,
00540        95,   83,   87,   89,   90,   96,   93,  251,   96,  105,
00541        98,  112,   84,   85,    7,    7,    8,    8,    8,    8,
00542 
00543         8,    8,    8,    8,    8,    8,    8,    8,    8,   91,
00544        97,   95,   90,   98,  100,  101,    8,  100,   99,  105,
00545       112,  104,  106,  101,  109,  106,  107,  103,   97,  111,
00546       113,  120,  124,  149,  120,  124,    8,    8,   44,   44,
00547        99,   44,   44,   44,  104,   44,   44,   44,  103,   44,
00548        44,  107,  115,  118,  109,  113,  119,  111,  122,  127,
00549       134,  149,  128,  127,  135,  115,  143,  163,  118,  143,
00550       119,  249,  138,  176,  122,  150,  176,  248,   44,   44,
00551        75,   75,  128,   75,   75,   75,  134,   75,   75,   75,
00552       138,   75,   75,  150,  135,  164,  163,  177,  247,  246,
00553 
00554       177,  245,  244,  243,  242,  239,  238,  237,  236,  235,
00555       234,  233,  164,  232,  231,  230,  229,  228,  226,  224,
00556        75,   75,  256,  256,  256,  256,  256,  257,  223,  222,
00557       257,  257,  259,  221,  259,  220,  259,  260,  219,  260,
00558       260,  260,  261,  218,  215,  261,  261,  262,  214,  262,
00559       213,  262,  212,  211,  210,  209,  208,  207,  206,  204,
00560       202,  201,  200,  199,  198,  197,  196,  195,  194,  193,
00561       192,  191,  190,  189,  188,  187,  186,  185,  184,  183,
00562       182,  181,  180,  179,  178,  175,  174,  173,  172,  171,
00563       170,  169,  168,  166,  165,  162,  161,  160,  159,  158,
00564 
00565       157,  156,  155,  154,  153,  152,  151,  148,  147,  146,
00566       145,  144,  141,  140,  139,  137,  136,  133,  132,  131,
00567       130,  129,  126,  125,  123,  121,  117,  116,  114,  110,
00568       108,  102,   94,   73,   72,   52,   51,   49,   47,   46,
00569        41,   40,   19,   16,   15,    9,  255,  255,  255,  255,
00570       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00571       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00572       255,  255,  255,  255,  255,  255,  255,  255,  255,  255,
00573       255,  255,  255,  255,  255,  255,  255,  255,  255
00574     } ;
00575 
00576 <font class="keyword">static</font> yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
00577 <font class="keyword">static</font> <font class="keywordtype">char</font> *yy_full_match;
00578 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_lp;
00579 <font class="preprocessor">#define REJECT \</font>
00580 <font class="preprocessor">{ \</font>
00581 <font class="preprocessor">*yy_cp = yy_hold_char; </font><font class="comment">/* undo effects of setting up yytext */</font> \
00582 yy_cp = yy_full_match; <font class="comment">/* restore poss. backed-over text */</font> \
00583 ++yy_lp; \
00584 goto find_rule; \
00585 }
00586 <font class="preprocessor">#define yymore() yymore_used_but_not_detected</font>
00587 <font class="preprocessor"></font><font class="preprocessor">#define YY_MORE_ADJ 0</font>
00588 <font class="preprocessor"></font><font class="preprocessor">#define YY_RESTORE_YY_MORE_OFFSET</font>
00589 <font class="preprocessor"></font><font class="keywordtype">char</font> *yytext;
00590 <font class="preprocessor">#line 1 "ExpSpec.lex"</font>
00591 <font class="preprocessor"></font><font class="preprocessor">#define INITIAL 0</font>
00592 <font class="preprocessor"></font>
00603 <font class="comment">/* this is a chunk of C code that is inserted before the lexical analyzer code,</font>
00604 <font class="comment">   it consists of all header inclusion and the definition of global variables</font>
00605 <font class="comment">   that are needed for exchanging information between the lexical analyzer and</font>
00606 <font class="comment">   the actual bison parser */</font>
00607 <font class="preprocessor">#line 18 "ExpSpec.lex"</font>
00608 <font class="preprocessor"></font><font class="preprocessor">#include &lt;string&gt;</font>
00609 <font class="preprocessor">#include "<a class="code" href="EasyLocal_h.html">EasyLocal.h</a>"</font>
00610 <font class="keyword">using</font> <font class="keyword">namespace </font>std;
00611 <font class="keyword">using</font> std::string;
00612 <font class="keyword">using</font> <font class="keyword">namespace </font>easylocal;
00613 <font class="preprocessor">#include "ExpSpec.tab.h"</font>
00614 
00615   
00616 <font class="comment">/* the YY_USER_ACTION defines the default action that will be taken when a</font>
00617 <font class="comment">   new lexical token has recognized */</font>
00618 
00619 <font class="preprocessor">#define YY_USER_ACTION yycolno += yyleng;</font>
00620 <font class="preprocessor"></font>
00621 <font class="comment">/* the yyparse function is an extern function provided by the bison parser</font>
00622 <font class="comment">   which simply start to parse a file */</font>
00623 <font class="keyword">extern</font> <font class="stringliteral">"C++"</font> <font class="keywordtype">int</font> <a class="code" href="EasyLocal_h.html#a4">yyparse</a>(<font class="keywordtype">void</font>);
00624 <font class="comment">/* yyerror is a bison function for error notifying */</font>
00625 <font class="keyword">extern</font> <font class="stringliteral">"C++"</font> <font class="keywordtype">int</font> yyerror(<font class="keyword">const</font> <font class="keywordtype">char</font>* s);
00626 
00627 <font class="keywordtype">char</font>* trimdelims(<font class="keyword">const</font> <font class="keywordtype">char</font>*);
00628 <font class="keywordtype">char</font>* copy(<font class="keyword">const</font> <font class="keywordtype">char</font>*);
00629 
00630 <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> yycolno = 0; <font class="comment">/* the column number */</font>
00631 <font class="keywordtype">int</font> comment_caller; <font class="comment">/* this variable contains the environment from which the comment is called */</font>
00632 <font class="keywordtype">int</font> string_caller; <font class="comment">/* this variable contains the environment from which the string is called */</font>
00633 <font class="keywordtype">char</font>* foo; 
00634 <font class="comment">/* now we have to define some options; among these we may define some lexical</font>
00635 <font class="comment">   environments for top-down parsing (problem, solver, runner, wm, comment).</font>
00636 <font class="comment">*/</font>
00637 <font class="preprocessor">#define YY_NEVER_INTERACTIVE 1</font>
00638 <font class="preprocessor"></font><font class="preprocessor">#define instance 1</font>
00639 <font class="preprocessor"></font>
00640 <font class="preprocessor">#define runner 2</font>
00641 <font class="preprocessor"></font>
00642 <font class="preprocessor">#define comment 3</font>
00643 <font class="preprocessor"></font>
00644 <font class="comment">/* here we define some shortcuts for lexical categories */</font>
00645 <font class="preprocessor">#line 646 "ExpSpec.yy.cpp"</font>
00646 <font class="preprocessor"></font>
00647 <font class="comment">/* Macros after this point can all be overridden by user definitions in</font>
00648 <font class="comment"> * section 1.</font>
00649 <font class="comment"> */</font>
00650 
00651 <font class="preprocessor">#ifndef YY_SKIP_YYWRAP</font>
00652 <font class="preprocessor"></font><font class="preprocessor">#ifdef __cplusplus</font>
00653 <font class="preprocessor"></font><font class="keyword">extern</font> <font class="stringliteral">"C"</font> <font class="keywordtype">int</font> yywrap YY_PROTO(( <font class="keywordtype">void</font> ));
00654 <font class="preprocessor">#else</font>
00655 <font class="preprocessor"></font><font class="keyword">extern</font> <font class="keywordtype">int</font> yywrap YY_PROTO(( <font class="keywordtype">void</font> ));
00656 <font class="preprocessor">#endif</font>
00657 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00658 <font class="preprocessor"></font>
00659 <font class="preprocessor">#ifndef YY_NO_UNPUT</font>
00660 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yyunput YY_PROTO(( <font class="keywordtype">int</font> c, <font class="keywordtype">char</font> *buf_ptr ));
00661 <font class="preprocessor">#endif</font>
00662 <font class="preprocessor"></font>
00663 <font class="preprocessor">#ifndef yytext_ptr</font>
00664 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_flex_strncpy YY_PROTO(( <font class="keywordtype">char</font> *, yyconst <font class="keywordtype">char</font> *, <font class="keywordtype">int</font> ));
00665 <font class="preprocessor">#endif</font>
00666 <font class="preprocessor"></font>
00667 <font class="preprocessor">#ifdef YY_NEED_STRLEN</font>
00668 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yy_flex_strlen YY_PROTO(( yyconst <font class="keywordtype">char</font> * ));
00669 <font class="preprocessor">#endif</font>
00670 <font class="preprocessor"></font>
00671 <font class="preprocessor">#ifndef YY_NO_INPUT</font>
00672 <font class="preprocessor"></font><font class="preprocessor">#ifdef __cplusplus</font>
00673 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yyinput YY_PROTO(( <font class="keywordtype">void</font> ));
00674 <font class="preprocessor">#else</font>
00675 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> input YY_PROTO(( <font class="keywordtype">void</font> ));
00676 <font class="preprocessor">#endif</font>
00677 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00678 <font class="preprocessor"></font>
00679 <font class="preprocessor">#if YY_STACK_USED</font>
00680 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yy_start_stack_ptr = 0;
00681 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_start_stack_depth = 0;
00682 <font class="keyword">static</font> <font class="keywordtype">int</font> *yy_start_stack = 0;
00683 <font class="preprocessor">#ifndef YY_NO_PUSH_STATE</font>
00684 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_push_state YY_PROTO(( <font class="keywordtype">int</font> new_state ));
00685 <font class="preprocessor">#endif</font>
00686 <font class="preprocessor"></font><font class="preprocessor">#ifndef YY_NO_POP_STATE</font>
00687 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_pop_state YY_PROTO(( <font class="keywordtype">void</font> ));
00688 <font class="preprocessor">#endif</font>
00689 <font class="preprocessor"></font><font class="preprocessor">#ifndef YY_NO_TOP_STATE</font>
00690 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yy_top_state YY_PROTO(( <font class="keywordtype">void</font> ));
00691 <font class="preprocessor">#endif</font>
00692 <font class="preprocessor"></font>
00693 <font class="preprocessor">#else</font>
00694 <font class="preprocessor"></font><font class="preprocessor">#define YY_NO_PUSH_STATE 1</font>
00695 <font class="preprocessor"></font><font class="preprocessor">#define YY_NO_POP_STATE 1</font>
00696 <font class="preprocessor"></font><font class="preprocessor">#define YY_NO_TOP_STATE 1</font>
00697 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00698 <font class="preprocessor"></font>
00699 <font class="preprocessor">#ifdef YY_MALLOC_DECL</font>
00700 <font class="preprocessor"></font>YY_MALLOC_DECL
00701 <font class="preprocessor">#else</font>
00702 <font class="preprocessor"></font><font class="preprocessor">#if __STDC__</font>
00703 <font class="preprocessor"></font><font class="preprocessor">#ifndef __cplusplus</font>
00704 <font class="preprocessor"></font><font class="preprocessor">#include &lt;stdlib.h&gt;</font>
00705 <font class="preprocessor">#endif</font>
00706 <font class="preprocessor"></font><font class="preprocessor">#else</font>
00707 <font class="preprocessor"></font><font class="comment">/* Just try to get by without declaring the routines.  This will fail</font>
00708 <font class="comment"> * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)</font>
00709 <font class="comment"> * or sizeof(void*) != sizeof(int).</font>
00710 <font class="comment"> */</font>
00711 <font class="preprocessor">#endif</font>
00712 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00713 <font class="preprocessor"></font>
00714 <font class="comment">/* Amount of stuff to slurp up with each read. */</font>
00715 <font class="preprocessor">#ifndef YY_READ_BUF_SIZE</font>
00716 <font class="preprocessor"></font><font class="preprocessor">#define YY_READ_BUF_SIZE 8192</font>
00717 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00718 <font class="preprocessor"></font>
00719 <font class="comment">/* Copy whatever the last rule matched to the standard output. */</font>
00720 
00721 <font class="preprocessor">#ifndef ECHO</font>
00722 <font class="preprocessor"></font><font class="comment">/* This used to be an fputs(), but since the string might contain NUL's,</font>
00723 <font class="comment"> * we now use fwrite().</font>
00724 <font class="comment"> */</font>
00725 <font class="preprocessor">#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )</font>
00726 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00727 <font class="preprocessor"></font>
00728 <font class="comment">/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,</font>
00729 <font class="comment"> * is returned in "result".</font>
00730 <font class="comment"> */</font>
00731 <font class="preprocessor">#ifndef YY_INPUT</font>
00732 <font class="preprocessor"></font><font class="preprocessor">#define YY_INPUT(buf,result,max_size) \</font>
00733 <font class="preprocessor">        if ( yy_current_buffer-&gt;yy_is_interactive ) \</font>
00734 <font class="preprocessor">                { \</font>
00735 <font class="preprocessor">                int c = '*', n; \</font>
00736 <font class="preprocessor">                for ( n = 0; n &lt; max_size &amp;&amp; \</font>
00737 <font class="preprocessor">                             (c = getc( yyin )) != EOF &amp;&amp; c != '\n'; ++n ) \</font>
00738 <font class="preprocessor">                        buf[n] = (char) c; \</font>
00739 <font class="preprocessor">                if ( c == '\n' ) \</font>
00740 <font class="preprocessor">                        buf[n++] = (char) c; \</font>
00741 <font class="preprocessor">                if ( c == EOF &amp;&amp; ferror( yyin ) ) \</font>
00742 <font class="preprocessor">                        YY_FATAL_ERROR( "input in flex scanner failed" ); \</font>
00743 <font class="preprocessor">                result = n; \</font>
00744 <font class="preprocessor">                } \</font>
00745 <font class="preprocessor">        else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \</font>
00746 <font class="preprocessor">                  &amp;&amp; ferror( yyin ) ) \</font>
00747 <font class="preprocessor">                YY_FATAL_ERROR( "input in flex scanner failed" );</font>
00748 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00749 <font class="preprocessor"></font>
00750 <font class="comment">/* No semi-colon after return; correct usage is to write "yyterminate();" -</font>
00751 <font class="comment"> * we don't want an extra ';' after the "return" because that will cause</font>
00752 <font class="comment"> * some compilers to complain about unreachable statements.</font>
00753 <font class="comment"> */</font>
00754 <font class="preprocessor">#ifndef yyterminate</font>
00755 <font class="preprocessor"></font><font class="preprocessor">#define yyterminate() return YY_NULL</font>
00756 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00757 <font class="preprocessor"></font>
00758 <font class="comment">/* Number of entries by which start-condition stack grows. */</font>
00759 <font class="preprocessor">#ifndef YY_START_STACK_INCR</font>
00760 <font class="preprocessor"></font><font class="preprocessor">#define YY_START_STACK_INCR 25</font>
00761 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00762 <font class="preprocessor"></font>
00763 <font class="comment">/* Report a fatal error. */</font>
00764 <font class="preprocessor">#ifndef YY_FATAL_ERROR</font>
00765 <font class="preprocessor"></font><font class="preprocessor">#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )</font>
00766 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00767 <font class="preprocessor"></font>
00768 <font class="comment">/* Default declaration of generated scanner - a define so the user can</font>
00769 <font class="comment"> * easily add parameters.</font>
00770 <font class="comment"> */</font>
00771 <font class="preprocessor">#ifndef YY_DECL</font>
00772 <font class="preprocessor"></font><font class="preprocessor">#define YY_DECL int yylex YY_PROTO(( void ))</font>
00773 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00774 <font class="preprocessor"></font>
00775 <font class="comment">/* Code executed at the beginning of each rule, after yytext and yyleng</font>
00776 <font class="comment"> * have been set up.</font>
00777 <font class="comment"> */</font>
00778 <font class="preprocessor">#ifndef YY_USER_ACTION</font>
00779 <font class="preprocessor"></font><font class="preprocessor">#define YY_USER_ACTION</font>
00780 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00781 <font class="preprocessor"></font>
00782 <font class="comment">/* Code executed at the end of each rule. */</font>
00783 <font class="preprocessor">#ifndef YY_BREAK</font>
00784 <font class="preprocessor"></font><font class="preprocessor">#define YY_BREAK break;</font>
00785 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00786 <font class="preprocessor"></font>
00787 <font class="preprocessor">#define YY_RULE_SETUP \</font>
00788 <font class="preprocessor">        YY_USER_ACTION</font>
00789 <font class="preprocessor"></font>
00790 YY_DECL
00791         {
00792         <font class="keyword">register</font> yy_state_type yy_current_state;
00793         <font class="keyword">register</font> <font class="keywordtype">char</font> *yy_cp, *yy_bp;
00794         <font class="keyword">register</font> <font class="keywordtype">int</font> yy_act;
00795 
00796 <font class="preprocessor">#line 72 "ExpSpec.lex"</font>
00797 <font class="preprocessor"></font>
00798 
00799 <font class="preprocessor">#line 800 "ExpSpec.yy.cpp"</font>
00800 <font class="preprocessor"></font>
00801         <font class="keywordflow">if</font> ( yy_init )
00802                 {
00803                 yy_init = 0;
00804 
00805 <font class="preprocessor">#ifdef YY_USER_INIT</font>
00806 <font class="preprocessor"></font>                YY_USER_INIT;
00807 <font class="preprocessor">#endif</font>
00808 <font class="preprocessor"></font>
00809                 <font class="keywordflow">if</font> ( ! yy_start )
00810                         yy_start = 1;   <font class="comment">/* first start state */</font>
00811 
00812                 <font class="keywordflow">if</font> ( ! yyin )
00813                         yyin = stdin;
00814 
00815                 <font class="keywordflow">if</font> ( ! yyout )
00816                         yyout = stdout;
00817 
00818                 <font class="keywordflow">if</font> ( ! yy_current_buffer )
00819                         yy_current_buffer =
00820                                 yy_create_buffer( yyin, YY_BUF_SIZE );
00821 
00822                 yy_load_buffer_state();
00823                 }
00824 
00825         <font class="keywordflow">while</font> ( 1 )             <font class="comment">/* loops until end-of-file is reached */</font>
00826                 {
00827                 yy_cp = yy_c_buf_p;
00828 
00829                 <font class="comment">/* Support of yytext. */</font>
00830                 *yy_cp = yy_hold_char;
00831 
00832                 <font class="comment">/* yy_bp points to the position in yy_ch_buf of the start of</font>
00833 <font class="comment">                 * the current run.</font>
00834 <font class="comment">                 */</font>
00835                 yy_bp = yy_cp;
00836 
00837                 yy_current_state = yy_start;
00838                 yy_state_ptr = yy_state_buf;
00839                 *yy_state_ptr++ = yy_current_state;
00840 yy_match:
00841                 <font class="keywordflow">do</font>
00842                         {
00843                         <font class="keyword">register</font> YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
00844                         <font class="keywordflow">while</font> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
00845                                 {
00846                                 yy_current_state = (<font class="keywordtype">int</font>) yy_def[yy_current_state];
00847                                 <font class="keywordflow">if</font> ( yy_current_state &gt;= 256 )
00848                                         yy_c = yy_meta[(<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) yy_c];
00849                                 }
00850                         yy_current_state = yy_nxt[yy_base[yy_current_state] + (<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) yy_c];
00851                         *yy_state_ptr++ = yy_current_state;
00852                         ++yy_cp;
00853                         }
00854                 <font class="keywordflow">while</font> ( yy_base[yy_current_state] != 447 );
00855 
00856 yy_find_action:
00857                 yy_current_state = *--yy_state_ptr;
00858                 yy_lp = yy_accept[yy_current_state];
00859 find_rule: <font class="comment">/* we branch to this label when backing up */</font>
00860                 <font class="keywordflow">for</font> ( ; ; ) <font class="comment">/* until we find what rule we matched */</font>
00861                         {
00862                         <font class="keywordflow">if</font> ( yy_lp &amp;&amp; yy_lp &lt; yy_accept[yy_current_state + 1] )
00863                                 {
00864                                 yy_act = yy_acclist[yy_lp];
00865                                         {
00866                                         yy_full_match = yy_cp;
00867                                         <font class="keywordflow">break</font>;
00868                                         }
00869                                 }
00870                         --yy_cp;
00871                         yy_current_state = *--yy_state_ptr;
00872                         yy_lp = yy_accept[yy_current_state];
00873                         }
00874 
00875                 YY_DO_BEFORE_ACTION;
00876 
00877                 <font class="keywordflow">if</font> ( yy_act != YY_END_OF_BUFFER )
00878                         {
00879                         <font class="keywordtype">int</font> yyl;
00880                         <font class="keywordflow">for</font> ( yyl = 0; yyl &lt; yyleng; ++yyl )
00881                                 <font class="keywordflow">if</font> ( yytext[yyl] == <font class="charliteral">'\n'</font> )
00882                                         ++yylineno;
00883                         }
00884 
00885 do_action:      <font class="comment">/* This label is used only to access EOF actions. */</font>
00886 
00887 
00888                 <font class="keywordflow">switch</font> ( yy_act )
00889         { <font class="comment">/* beginning of action switch */</font>
00890 <font class="keywordflow">case</font> 1:
00891 YY_RULE_SETUP
00892 <font class="preprocessor">#line 74 "ExpSpec.lex"</font>
00893 <font class="preprocessor"></font>comment_caller = YYSTATE;  BEGIN(comment); 
00894         YY_BREAK
00895 
00896 <font class="keywordflow">case</font> 2:
00897 YY_RULE_SETUP
00898 <font class="preprocessor">#line 76 "ExpSpec.lex"</font>
00899 <font class="preprocessor"></font><font class="comment">/* eat anything but a `*' */</font>       
00900         YY_BREAK
00901 <font class="keywordflow">case</font> 3:
00902 YY_RULE_SETUP
00903 <font class="preprocessor">#line 77 "ExpSpec.lex"</font>
00904 <font class="preprocessor"></font><font class="comment">/* eat the `*' not followed by a `/' */</font>
00905         YY_BREAK
00906 <font class="keywordflow">case</font> 4:
00907 YY_RULE_SETUP
00908 <font class="preprocessor">#line 78 "ExpSpec.lex"</font>
00909 <font class="preprocessor"></font>BEGIN(comment_caller); <font class="comment">/* restart from last environment */</font>
00910         YY_BREAK
00911 
00912 <font class="keywordflow">case</font> 5:
00913 YY_RULE_SETUP
00914 <font class="preprocessor">#line 81 "ExpSpec.lex"</font>
00915 <font class="preprocessor"></font>BEGIN(instance); <font class="keywordflow">return</font> INSTANCE; 
00916         YY_BREAK
00917 
00918 <font class="keywordflow">case</font> 6:
00919 YY_RULE_SETUP
00920 <font class="preprocessor">#line 84 "ExpSpec.lex"</font>
00921 <font class="preprocessor"></font><font class="keywordflow">return</font> LOG_FILE;
00922         YY_BREAK
00923 <font class="keywordflow">case</font> 7:
00924 YY_RULE_SETUP
00925 <font class="preprocessor">#line 85 "ExpSpec.lex"</font>
00926 <font class="preprocessor"></font><font class="keywordflow">return</font> OUTPUT_PREFIX;
00927         YY_BREAK
00928 <font class="keywordflow">case</font> 8:
00929 YY_RULE_SETUP
00930 <font class="preprocessor">#line 86 "ExpSpec.lex"</font>
00931 <font class="preprocessor"></font><font class="keywordflow">return</font> PLOT_PREFIX;
00932         YY_BREAK
00933 <font class="keywordflow">case</font> 9:
00934 YY_RULE_SETUP
00935 <font class="preprocessor">#line 87 "ExpSpec.lex"</font>
00936 <font class="preprocessor"></font><font class="keywordflow">return</font> TRIALS;
00937         YY_BREAK
00938 <font class="keywordflow">case</font> 10:
00939 YY_RULE_SETUP
00940 <font class="preprocessor">#line 88 "ExpSpec.lex"</font>
00941 <font class="preprocessor"></font>BEGIN(runner); <font class="keywordflow">return</font> RUNNER;
00942         YY_BREAK
00943 <font class="keywordflow">case</font> 11:
00944 YY_RULE_SETUP
00945 <font class="preprocessor">#line 89 "ExpSpec.lex"</font>
00946 <font class="preprocessor"></font>{  
00947                          <font class="comment">/* end block, go back to the initial state */</font>
00948                          BEGIN(INITIAL); <font class="keywordflow">return</font> EBLOCK;
00949                        } 
00950         YY_BREAK
00951 
00952 
00953 <font class="keywordflow">case</font> 12:
00954 YY_RULE_SETUP
00955 <font class="preprocessor">#line 96 "ExpSpec.lex"</font>
00956 <font class="preprocessor"></font><font class="keywordflow">return</font> HILL_CLIMBING;
00957         YY_BREAK
00958 <font class="keywordflow">case</font> 13:
00959 YY_RULE_SETUP
00960 <font class="preprocessor">#line 97 "ExpSpec.lex"</font>
00961 <font class="preprocessor"></font><font class="keywordflow">return</font> TABU_SEARCH;
00962         YY_BREAK
00963 <font class="keywordflow">case</font> 14:
00964 YY_RULE_SETUP
00965 <font class="preprocessor">#line 98 "ExpSpec.lex"</font>
00966 <font class="preprocessor"></font><font class="keywordflow">return</font> SIMULATED_ANNEALING;
00967         YY_BREAK
00968 <font class="keywordflow">case</font> 15:
00969 YY_RULE_SETUP
00970 <font class="preprocessor">#line 99 "ExpSpec.lex"</font>
00971 <font class="preprocessor"></font><font class="keywordflow">return</font> MAX_ITERATION;
00972         YY_BREAK
00973 <font class="keywordflow">case</font> 16:
00974 YY_RULE_SETUP
00975 <font class="preprocessor">#line 100 "ExpSpec.lex"</font>
00976 <font class="preprocessor"></font><font class="keywordflow">return</font> MAX_IDLE_ITERATION;
00977         YY_BREAK
00978 <font class="keywordflow">case</font> 17:
00979 YY_RULE_SETUP
00980 <font class="preprocessor">#line 101 "ExpSpec.lex"</font>
00981 <font class="preprocessor"></font><font class="keywordflow">return</font> MAX_TABU_TENURE;
00982         YY_BREAK
00983 <font class="keywordflow">case</font> 18:
00984 YY_RULE_SETUP
00985 <font class="preprocessor">#line 102 "ExpSpec.lex"</font>
00986 <font class="preprocessor"></font><font class="keywordflow">return</font> MIN_TABU_TENURE;
00987         YY_BREAK
00988 <font class="keywordflow">case</font> 19:
00989 YY_RULE_SETUP
00990 <font class="preprocessor">#line 103 "ExpSpec.lex"</font>
00991 <font class="preprocessor"></font><font class="keywordflow">return</font> START_TEMPERATURE;
00992         YY_BREAK
00993 <font class="keywordflow">case</font> 20:
00994 YY_RULE_SETUP
00995 <font class="preprocessor">#line 104 "ExpSpec.lex"</font>
00996 <font class="preprocessor"></font><font class="keywordflow">return</font> COOLING_RATE; 
00997         YY_BREAK
00998 <font class="keywordflow">case</font> 21:
00999 YY_RULE_SETUP
01000 <font class="preprocessor">#line 105 "ExpSpec.lex"</font>
01001 <font class="preprocessor"></font><font class="keywordflow">return</font> NEIGHBORS_SAMPLED;
01002         YY_BREAK
01003 <font class="keywordflow">case</font> 22:
01004 YY_RULE_SETUP
01005 <font class="preprocessor">#line 106 "ExpSpec.lex"</font>
01006 <font class="preprocessor"></font>{
01007                          <font class="comment">/* end block, go back to the previous state */</font> 
01008                          BEGIN(instance); <font class="keywordflow">return</font> EBLOCK; 
01009                        }
01010         YY_BREAK
01011 
01012 <font class="keywordflow">case</font> 23:
01013 YY_RULE_SETUP
01014 <font class="preprocessor">#line 112 "ExpSpec.lex"</font>
01015 <font class="preprocessor"></font><font class="keywordflow">return</font> BBLOCK;  <font class="comment">/* beginning block */</font>
01016         YY_BREAK
01017 <font class="keywordflow">case</font> 24:
01018 YY_RULE_SETUP
01019 <font class="preprocessor">#line 113 "ExpSpec.lex"</font>
01020 <font class="preprocessor"></font><font class="keywordflow">return</font> ESTMT;   <font class="comment">/* end of statement `;' */</font>
01021         YY_BREAK
01022 <font class="keywordflow">case</font> 25:
01023 YY_RULE_SETUP
01024 <font class="preprocessor">#line 115 "ExpSpec.lex"</font>
01025 <font class="preprocessor"></font>yylval.char_string = <font class="keyword">new</font> string(trimdelims(yytext)); <font class="keywordflow">return</font> STRING;
01026         YY_BREAK
01027 <font class="keywordflow">case</font> 26:
01028 YY_RULE_SETUP
01029 <font class="preprocessor">#line 116 "ExpSpec.lex"</font>
01030 <font class="preprocessor"></font>yylval.natural = strtoul(yytext,&amp;foo,0); <font class="keywordflow">return</font> NATURAL; 
01031         YY_BREAK
01032 <font class="keywordflow">case</font> 27:
01033 YY_RULE_SETUP
01034 <font class="preprocessor">#line 117 "ExpSpec.lex"</font>
01035 <font class="preprocessor"></font>yylval.real = strtod(yytext,&amp;foo); <font class="keywordflow">return</font> REAL;
01036         YY_BREAK
01037 <font class="keywordflow">case</font> 28:
01038 YY_RULE_SETUP
01039 <font class="preprocessor">#line 118 "ExpSpec.lex"</font>
01040 <font class="preprocessor"></font>yylval.char_string =  <font class="keyword">new</font> string(yytext); <font class="keywordflow">return</font> IDENTIFIER; 
01041         YY_BREAK
01042 <font class="keywordflow">case</font> 29:
01043 YY_RULE_SETUP
01044 <font class="preprocessor">#line 120 "ExpSpec.lex"</font>
01045 <font class="preprocessor"></font><font class="comment">/* skips the blanks and the carriage returns */</font>
01046         YY_BREAK
01047 <font class="keywordflow">case</font> 30:
01048 YY_RULE_SETUP
01049 <font class="preprocessor">#line 121 "ExpSpec.lex"</font>
01050 <font class="preprocessor"></font>{
01051                          <font class="comment">/* skips the tabs and update the column count */</font> 
01052                          yycolno += 7;                         
01053                        }
01054         YY_BREAK
01055 <font class="keywordflow">case</font> 31:
01056 YY_RULE_SETUP
01057 <font class="preprocessor">#line 125 "ExpSpec.lex"</font>
01058 <font class="preprocessor"></font>{
01059                          <font class="comment">/* skipping the newline involves the update </font>
01060 <font class="comment">                                                    of the column number */</font>
01061                          yycolno = 0;
01062                        }
01063         YY_BREAK
01064 <font class="keywordflow">case</font> 32:
01065 YY_RULE_SETUP
01066 <font class="preprocessor">#line 132 "ExpSpec.lex"</font>
01067 <font class="preprocessor"></font>{ <font class="comment">/* overrules the default rule that echos all the </font>
01068 <font class="comment">                                                    unmatched input raising a syntax error message </font>
01069 <font class="comment">                                                        as output */</font>
01070                          yyerror(<font class="stringliteral">"syntax error"</font>);
01071                                              yyterminate();
01072                        }
01073         YY_BREAK
01074 <font class="keywordflow">case</font> 33:
01075 YY_RULE_SETUP
01076 <font class="preprocessor">#line 139 "ExpSpec.lex"</font>
01077 <font class="preprocessor"></font>ECHO;
01078         YY_BREAK
01079 <font class="preprocessor">#line 1080 "ExpSpec.yy.cpp"</font>
01080 <font class="preprocessor"></font>                        <font class="keywordflow">case</font> YY_STATE_EOF(INITIAL):
01081                         case YY_STATE_EOF(instance):
01082                         case YY_STATE_EOF(runner):
01083                         case YY_STATE_EOF(comment):
01084                                 yyterminate();
01085 
01086         <font class="keywordflow">case</font> YY_END_OF_BUFFER:
01087                 {
01088                 <font class="comment">/* Amount of text matched not including the EOB char. */</font>
01089                 <font class="keywordtype">int</font> yy_amount_of_matched_text = (<font class="keywordtype">int</font>) (yy_cp - yytext_ptr) - 1;
01090 
01091                 <font class="comment">/* Undo the effects of YY_DO_BEFORE_ACTION. */</font>
01092                 *yy_cp = yy_hold_char;
01093                 YY_RESTORE_YY_MORE_OFFSET
01094 
01095                 <font class="keywordflow">if</font> ( yy_current_buffer-&gt;yy_buffer_status == YY_BUFFER_NEW )
01096                         {
01097                         <font class="comment">/* We're scanning a new file or input source.  It's</font>
01098 <font class="comment">                         * possible that this happened because the user</font>
01099 <font class="comment">                         * just pointed yyin at a new source and called</font>
01100 <font class="comment">                         * yylex().  If so, then we have to assure</font>
01101 <font class="comment">                         * consistency between yy_current_buffer and our</font>
01102 <font class="comment">                         * globals.  Here is the right place to do so, because</font>
01103 <font class="comment">                         * this is the first action (other than possibly a</font>
01104 <font class="comment">                         * back-up) that will match for the new input source.</font>
01105 <font class="comment">                         */</font>
01106                         yy_n_chars = yy_current_buffer-&gt;yy_n_chars;
01107                         yy_current_buffer-&gt;yy_input_file = yyin;
01108                         yy_current_buffer-&gt;yy_buffer_status = YY_BUFFER_NORMAL;
01109                         }
01110 
01111                 <font class="comment">/* Note that here we test for yy_c_buf_p "&lt;=" to the position</font>
01112 <font class="comment">                 * of the first EOB in the buffer, since yy_c_buf_p will</font>
01113 <font class="comment">                 * already have been incremented past the NUL character</font>
01114 <font class="comment">                 * (since all states make transitions on EOB to the</font>
01115 <font class="comment">                 * end-of-buffer state).  Contrast this with the test</font>
01116 <font class="comment">                 * in input().</font>
01117 <font class="comment">                 */</font>
01118                 <font class="keywordflow">if</font> ( yy_c_buf_p &lt;= &amp;yy_current_buffer-&gt;yy_ch_buf[yy_n_chars] )
01119                         { <font class="comment">/* This was really a NUL. */</font>
01120                         yy_state_type yy_next_state;
01121 
01122                         yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
01123 
01124                         yy_current_state = yy_get_previous_state();
01125 
01126                         <font class="comment">/* Okay, we're now positioned to make the NUL</font>
01127 <font class="comment">                         * transition.  We couldn't have</font>
01128 <font class="comment">                         * yy_get_previous_state() go ahead and do it</font>
01129 <font class="comment">                         * for us because it doesn't know how to deal</font>
01130 <font class="comment">                         * with the possibility of jamming (and we don't</font>
01131 <font class="comment">                         * want to build jamming into it because then it</font>
01132 <font class="comment">                         * will run more slowly).</font>
01133 <font class="comment">                         */</font>
01134 
01135                         yy_next_state = yy_try_NUL_trans( yy_current_state );
01136 
01137                         yy_bp = yytext_ptr + YY_MORE_ADJ;
01138 
01139                         <font class="keywordflow">if</font> ( yy_next_state )
01140                                 {
01141                                 <font class="comment">/* Consume the NUL. */</font>
01142                                 yy_cp = ++yy_c_buf_p;
01143                                 yy_current_state = yy_next_state;
01144                                 <font class="keywordflow">goto</font> yy_match;
01145                                 }
01146 
01147                         <font class="keywordflow">else</font>
01148                                 {
01149                                 yy_cp = yy_c_buf_p;
01150                                 <font class="keywordflow">goto</font> yy_find_action;
01151                                 }
01152                         }
01153 
01154                 <font class="keywordflow">else</font> <font class="keywordflow">switch</font> ( yy_get_next_buffer() )
01155                         {
01156                         <font class="keywordflow">case</font> EOB_ACT_END_OF_FILE:
01157                                 {
01158                                 yy_did_buffer_switch_on_eof = 0;
01159 
01160                                 <font class="keywordflow">if</font> ( yywrap() )
01161                                         {
01162                                         <font class="comment">/* Note: because we've taken care in</font>
01163 <font class="comment">                                         * yy_get_next_buffer() to have set up</font>
01164 <font class="comment">                                         * yytext, we can now set up</font>
01165 <font class="comment">                                         * yy_c_buf_p so that if some total</font>
01166 <font class="comment">                                         * hoser (like flex itself) wants to</font>
01167 <font class="comment">                                         * call the scanner after we return the</font>
01168 <font class="comment">                                         * YY_NULL, it'll still work - another</font>
01169 <font class="comment">                                         * YY_NULL will get returned.</font>
01170 <font class="comment">                                         */</font>
01171                                         yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
01172 
01173                                         yy_act = YY_STATE_EOF(YY_START);
01174                                         <font class="keywordflow">goto</font> do_action;
01175                                         }
01176 
01177                                 <font class="keywordflow">else</font>
01178                                         {
01179                                         <font class="keywordflow">if</font> ( ! yy_did_buffer_switch_on_eof )
01180                                                 YY_NEW_FILE;
01181                                         }
01182                                 <font class="keywordflow">break</font>;
01183                                 }
01184 
01185                         <font class="keywordflow">case</font> EOB_ACT_CONTINUE_SCAN:
01186                                 yy_c_buf_p =
01187                                         yytext_ptr + yy_amount_of_matched_text;
01188 
01189                                 yy_current_state = yy_get_previous_state();
01190 
01191                                 yy_cp = yy_c_buf_p;
01192                                 yy_bp = yytext_ptr + YY_MORE_ADJ;
01193                                 <font class="keywordflow">goto</font> yy_match;
01194 
01195                         <font class="keywordflow">case</font> EOB_ACT_LAST_MATCH:
01196                                 yy_c_buf_p =
01197                                 &amp;yy_current_buffer-&gt;yy_ch_buf[yy_n_chars];
01198 
01199                                 yy_current_state = yy_get_previous_state();
01200 
01201                                 yy_cp = yy_c_buf_p;
01202                                 yy_bp = yytext_ptr + YY_MORE_ADJ;
01203                                 <font class="keywordflow">goto</font> yy_find_action;
01204                         }
01205                 <font class="keywordflow">break</font>;
01206                 }
01207 
01208         <font class="keywordflow">default</font>:
01209                 YY_FATAL_ERROR(
01210                         <font class="stringliteral">"fatal flex scanner internal error--no action found"</font> );
01211         } <font class="comment">/* end of action switch */</font>
01212                 } <font class="comment">/* end of scanning one token */</font>
01213         } <font class="comment">/* end of yylex */</font>
01214 
01215 
01216 <font class="comment">/* yy_get_next_buffer - try to read in a new buffer</font>
01217 <font class="comment"> *</font>
01218 <font class="comment"> * Returns a code representing an action:</font>
01219 <font class="comment"> *      EOB_ACT_LAST_MATCH -</font>
01220 <font class="comment"> *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position</font>
01221 <font class="comment"> *      EOB_ACT_END_OF_FILE - end of file</font>
01222 <font class="comment"> */</font>
01223 
01224 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_get_next_buffer()<font class="keyword"></font>
01225 <font class="keyword">        </font>{
01226         <font class="keyword">register</font> <font class="keywordtype">char</font> *dest = yy_current_buffer-&gt;yy_ch_buf;
01227         <font class="keyword">register</font> <font class="keywordtype">char</font> *source = yytext_ptr;
01228         <font class="keyword">register</font> <font class="keywordtype">int</font> number_to_move, i;
01229         <font class="keywordtype">int</font> ret_val;
01230 
01231         <font class="keywordflow">if</font> ( yy_c_buf_p &gt; &amp;yy_current_buffer-&gt;yy_ch_buf[yy_n_chars + 1] )
01232                 YY_FATAL_ERROR(
01233                 <font class="stringliteral">"fatal flex scanner internal error--end of buffer missed"</font> );
01234 
01235         <font class="keywordflow">if</font> ( yy_current_buffer-&gt;yy_fill_buffer == 0 )
01236                 { <font class="comment">/* Don't try to fill the buffer, so this is an EOF. */</font>
01237                 <font class="keywordflow">if</font> ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
01238                         {
01239                         <font class="comment">/* We matched a single character, the EOB, so</font>
01240 <font class="comment">                         * treat this as a final EOF.</font>
01241 <font class="comment">                         */</font>
01242                         <font class="keywordflow">return</font> EOB_ACT_END_OF_FILE;
01243                         }
01244 
01245                 <font class="keywordflow">else</font>
01246                         {
01247                         <font class="comment">/* We matched some text prior to the EOB, first</font>
01248 <font class="comment">                         * process it.</font>
01249 <font class="comment">                         */</font>
01250                         <font class="keywordflow">return</font> EOB_ACT_LAST_MATCH;
01251                         }
01252                 }
01253 
01254         <font class="comment">/* Try to read more data. */</font>
01255 
01256         <font class="comment">/* First move last chars to start of buffer. */</font>
01257         number_to_move = (<font class="keywordtype">int</font>) (yy_c_buf_p - yytext_ptr) - 1;
01258 
01259         <font class="keywordflow">for</font> ( i = 0; i &lt; number_to_move; ++i )
01260                 *(dest++) = *(source++);
01261 
01262         <font class="keywordflow">if</font> ( yy_current_buffer-&gt;yy_buffer_status == YY_BUFFER_EOF_PENDING )
01263                 <font class="comment">/* don't do the read, it's not guaranteed to return an EOF,</font>
01264 <font class="comment">                 * just force an EOF</font>
01265 <font class="comment">                 */</font>
01266                 yy_current_buffer-&gt;yy_n_chars = yy_n_chars = 0;
01267 
01268         <font class="keywordflow">else</font>
01269                 {
01270                 <font class="keywordtype">int</font> num_to_read =
01271                         yy_current_buffer-&gt;yy_buf_size - number_to_move - 1;
01272 
01273                 <font class="keywordflow">while</font> ( num_to_read &lt;= 0 )
01274                         { <font class="comment">/* Not enough room in the buffer - grow it. */</font>
01275 <font class="preprocessor">#ifdef YY_USES_REJECT</font>
01276 <font class="preprocessor"></font>                        YY_FATAL_ERROR(
01277 <font class="stringliteral">"input buffer overflow, can't enlarge buffer because scanner uses REJECT"</font> );
01278 <font class="preprocessor">#else</font>
01279 <font class="preprocessor"></font>
01280                         <font class="comment">/* just a shorter name for the current buffer */</font>
01281                         YY_BUFFER_STATE b = yy_current_buffer;
01282 
01283                         <font class="keywordtype">int</font> yy_c_buf_p_offset =
01284                                 (<font class="keywordtype">int</font>) (yy_c_buf_p - b-&gt;yy_ch_buf);
01285 
01286                         <font class="keywordflow">if</font> ( b-&gt;yy_is_our_buffer )
01287                                 {
01288                                 <font class="keywordtype">int</font> new_size = b-&gt;yy_buf_size * 2;
01289 
01290                                 <font class="keywordflow">if</font> ( new_size &lt;= 0 )
01291                                         b-&gt;yy_buf_size += b-&gt;yy_buf_size / 8;
01292                                 <font class="keywordflow">else</font>
01293                                         b-&gt;yy_buf_size *= 2;
01294 
01295                                 b-&gt;yy_ch_buf = (<font class="keywordtype">char</font> *)
01296                                         <font class="comment">/* Include room in for 2 EOB chars. */</font>
01297                                         yy_flex_realloc( (<font class="keywordtype">void</font> *) b-&gt;yy_ch_buf,
01298                                                          b-&gt;yy_buf_size + 2 );
01299                                 }
01300                         <font class="keywordflow">else</font>
01301                                 <font class="comment">/* Can't grow it, we don't own it. */</font>
01302                                 b-&gt;yy_ch_buf = 0;
01303 
01304                         <font class="keywordflow">if</font> ( ! b-&gt;yy_ch_buf )
01305                                 YY_FATAL_ERROR(
01306                                 <font class="stringliteral">"fatal error - scanner input buffer overflow"</font> );
01307 
01308                         yy_c_buf_p = &amp;b-&gt;yy_ch_buf[yy_c_buf_p_offset];
01309 
01310                         num_to_read = yy_current_buffer-&gt;yy_buf_size -
01311                                                 number_to_move - 1;
01312 <font class="preprocessor">#endif</font>
01313 <font class="preprocessor"></font>                        }
01314 
01315                 <font class="keywordflow">if</font> ( num_to_read &gt; YY_READ_BUF_SIZE )
01316                         num_to_read = YY_READ_BUF_SIZE;
01317 
01318                 <font class="comment">/* Read in more data. */</font>
01319                 YY_INPUT( (&amp;yy_current_buffer-&gt;yy_ch_buf[number_to_move]),
01320                         yy_n_chars, num_to_read );
01321 
01322                 yy_current_buffer-&gt;yy_n_chars = yy_n_chars;
01323                 }
01324 
01325         <font class="keywordflow">if</font> ( yy_n_chars == 0 )
01326                 {
01327                 <font class="keywordflow">if</font> ( number_to_move == YY_MORE_ADJ )
01328                         {
01329                         ret_val = EOB_ACT_END_OF_FILE;
01330                         yyrestart( yyin );
01331                         }
01332 
01333                 <font class="keywordflow">else</font>
01334                         {
01335                         ret_val = EOB_ACT_LAST_MATCH;
01336                         yy_current_buffer-&gt;yy_buffer_status =
01337                                 YY_BUFFER_EOF_PENDING;
01338                         }
01339                 }
01340 
01341         <font class="keywordflow">else</font>
01342                 ret_val = EOB_ACT_CONTINUE_SCAN;
01343 
01344         yy_n_chars += number_to_move;
01345         yy_current_buffer-&gt;yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
01346         yy_current_buffer-&gt;yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
01347 
01348         yytext_ptr = &amp;yy_current_buffer-&gt;yy_ch_buf[0];
01349 
01350         <font class="keywordflow">return</font> ret_val;
01351         }
01352 
01353 
01354 <font class="comment">/* yy_get_previous_state - get the state just before the EOB char was reached */</font>
01355 
01356 <font class="keyword">static</font> yy_state_type yy_get_previous_state()<font class="keyword"></font>
01357 <font class="keyword">        </font>{
01358         <font class="keyword">register</font> yy_state_type yy_current_state;
01359         <font class="keyword">register</font> <font class="keywordtype">char</font> *yy_cp;
01360 
01361         yy_current_state = yy_start;
01362         yy_state_ptr = yy_state_buf;
01363         *yy_state_ptr++ = yy_current_state;
01364 
01365         <font class="keywordflow">for</font> ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp &lt; yy_c_buf_p; ++yy_cp )
01366                 {
01367                 <font class="keyword">register</font> YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
01368                 <font class="keywordflow">while</font> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
01369                         {
01370                         yy_current_state = (<font class="keywordtype">int</font>) yy_def[yy_current_state];
01371                         <font class="keywordflow">if</font> ( yy_current_state &gt;= 256 )
01372                                 yy_c = yy_meta[(<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) yy_c];
01373                         }
01374                 yy_current_state = yy_nxt[yy_base[yy_current_state] + (<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) yy_c];
01375                 *yy_state_ptr++ = yy_current_state;
01376                 }
01377 
01378         <font class="keywordflow">return</font> yy_current_state;
01379         }
01380 
01381 
01382 <font class="comment">/* yy_try_NUL_trans - try to make a transition on the NUL character</font>
01383 <font class="comment"> *</font>
01384 <font class="comment"> * synopsis</font>
01385 <font class="comment"> *      next_state = yy_try_NUL_trans( current_state );</font>
01386 <font class="comment"> */</font>
01387 
01388 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01389 <font class="preprocessor"></font><font class="keyword">static</font> yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
01390 <font class="preprocessor">#else</font>
01391 <font class="preprocessor"></font><font class="keyword">static</font> yy_state_type yy_try_NUL_trans( yy_current_state )
01392 yy_state_type yy_current_state;
01393 <font class="preprocessor">#endif</font>
01394 <font class="preprocessor"></font>        {
01395         <font class="keyword">register</font> <font class="keywordtype">int</font> yy_is_jam;
01396 
01397         <font class="keyword">register</font> YY_CHAR yy_c = 1;
01398         <font class="keywordflow">while</font> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
01399                 {
01400                 yy_current_state = (<font class="keywordtype">int</font>) yy_def[yy_current_state];
01401                 <font class="keywordflow">if</font> ( yy_current_state &gt;= 256 )
01402                         yy_c = yy_meta[(<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) yy_c];
01403                 }
01404         yy_current_state = yy_nxt[yy_base[yy_current_state] + (<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) yy_c];
01405         yy_is_jam = (yy_current_state == 255);
01406         <font class="keywordflow">if</font> ( ! yy_is_jam )
01407                 *yy_state_ptr++ = yy_current_state;
01408 
01409         <font class="keywordflow">return</font> yy_is_jam ? 0 : yy_current_state;
01410         }
01411 
01412 
01413 <font class="preprocessor">#ifndef YY_NO_UNPUT</font>
01414 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01415 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yyunput( <font class="keywordtype">int</font> c, <font class="keyword">register</font> <font class="keywordtype">char</font> *yy_bp )
01416 <font class="preprocessor">#else</font>
01417 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yyunput( c, yy_bp )
01418 <font class="keywordtype">int</font> c;
01419 <font class="keyword">register</font> <font class="keywordtype">char</font> *yy_bp;
01420 <font class="preprocessor">#endif</font>
01421 <font class="preprocessor"></font>        {
01422         <font class="keyword">register</font> <font class="keywordtype">char</font> *yy_cp = yy_c_buf_p;
01423 
01424         <font class="comment">/* undo effects of setting up yytext */</font>
01425         *yy_cp = yy_hold_char;
01426 
01427         <font class="keywordflow">if</font> ( yy_cp &lt; yy_current_buffer-&gt;yy_ch_buf + 2 )
01428                 { <font class="comment">/* need to shift things up to make room */</font>
01429                 <font class="comment">/* +2 for EOB chars. */</font>
01430                 <font class="keyword">register</font> <font class="keywordtype">int</font> number_to_move = yy_n_chars + 2;
01431                 <font class="keyword">register</font> <font class="keywordtype">char</font> *dest = &amp;yy_current_buffer-&gt;yy_ch_buf[
01432                                         yy_current_buffer-&gt;yy_buf_size + 2];
01433                 <font class="keyword">register</font> <font class="keywordtype">char</font> *source =
01434                                 &amp;yy_current_buffer-&gt;yy_ch_buf[number_to_move];
01435 
01436                 <font class="keywordflow">while</font> ( source &gt; yy_current_buffer-&gt;yy_ch_buf )
01437                         *--dest = *--source;
01438 
01439                 yy_cp += (<font class="keywordtype">int</font>) (dest - source);
01440                 yy_bp += (<font class="keywordtype">int</font>) (dest - source);
01441                 yy_current_buffer-&gt;yy_n_chars =
01442                         yy_n_chars = yy_current_buffer-&gt;yy_buf_size;
01443 
01444                 <font class="keywordflow">if</font> ( yy_cp &lt; yy_current_buffer-&gt;yy_ch_buf + 2 )
01445                         YY_FATAL_ERROR( <font class="stringliteral">"flex scanner push-back overflow"</font> );
01446                 }
01447 
01448         *--yy_cp = (<font class="keywordtype">char</font>) c;
01449 
01450         <font class="keywordflow">if</font> ( c == <font class="charliteral">'\n'</font> )
01451                 --yylineno;
01452 
01453         yytext_ptr = yy_bp;
01454         yy_hold_char = *yy_cp;
01455         yy_c_buf_p = yy_cp;
01456         }
01457 <font class="preprocessor">#endif  </font><font class="comment">/* ifndef YY_NO_UNPUT */</font>
01458 
01459 
01460 <font class="preprocessor">#ifdef __cplusplus</font>
01461 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yyinput()
01462 <font class="preprocessor">#else</font>
01463 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> input()
01464 <font class="preprocessor">#endif</font>
01465 <font class="preprocessor"></font>        {
01466         <font class="keywordtype">int</font> c;
01467 
01468         *yy_c_buf_p = yy_hold_char;
01469 
01470         <font class="keywordflow">if</font> ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
01471                 {
01472                 <font class="comment">/* yy_c_buf_p now points to the character we want to return.</font>
01473 <font class="comment">                 * If this occurs *before* the EOB characters, then it's a</font>
01474 <font class="comment">                 * valid NUL; if not, then we've hit the end of the buffer.</font>
01475 <font class="comment">                 */</font>
01476                 <font class="keywordflow">if</font> ( yy_c_buf_p &lt; &amp;yy_current_buffer-&gt;yy_ch_buf[yy_n_chars] )
01477                         <font class="comment">/* This was really a NUL. */</font>
01478                         *yy_c_buf_p = <font class="charliteral">'\0'</font>;
01479 
01480                 <font class="keywordflow">else</font>
01481                         { <font class="comment">/* need more input */</font>
01482                         <font class="keywordtype">int</font> offset = yy_c_buf_p - yytext_ptr;
01483                         ++yy_c_buf_p;
01484 
01485                         <font class="keywordflow">switch</font> ( yy_get_next_buffer() )
01486                                 {
01487                                 <font class="keywordflow">case</font> EOB_ACT_LAST_MATCH:
01488                                         <font class="comment">/* This happens because yy_g_n_b()</font>
01489 <font class="comment">                                         * sees that we've accumulated a</font>
01490 <font class="comment">                                         * token and flags that we need to</font>
01491 <font class="comment">                                         * try matching the token before</font>
01492 <font class="comment">                                         * proceeding.  But for input(),</font>
01493 <font class="comment">                                         * there's no matching to consider.</font>
01494 <font class="comment">                                         * So convert the EOB_ACT_LAST_MATCH</font>
01495 <font class="comment">                                         * to EOB_ACT_END_OF_FILE.</font>
01496 <font class="comment">                                         */</font>
01497 
01498                                         <font class="comment">/* Reset buffer status. */</font>
01499                                         yyrestart( yyin );
01500 
01501                                         <font class="comment">/* fall through */</font>
01502 
01503                                 <font class="keywordflow">case</font> EOB_ACT_END_OF_FILE:
01504                                         {
01505                                         <font class="keywordflow">if</font> ( yywrap() )
01506                                                 <font class="keywordflow">return</font> EOF;
01507 
01508                                         <font class="keywordflow">if</font> ( ! yy_did_buffer_switch_on_eof )
01509                                                 YY_NEW_FILE;
01510 <font class="preprocessor">#ifdef __cplusplus</font>
01511 <font class="preprocessor"></font>                                        <font class="keywordflow">return</font> yyinput();
01512 <font class="preprocessor">#else</font>
01513 <font class="preprocessor"></font>                                        <font class="keywordflow">return</font> input();
01514 <font class="preprocessor">#endif</font>
01515 <font class="preprocessor"></font>                                        }
01516 
01517                                 <font class="keywordflow">case</font> EOB_ACT_CONTINUE_SCAN:
01518                                         yy_c_buf_p = yytext_ptr + offset;
01519                                         <font class="keywordflow">break</font>;
01520                                 }
01521                         }
01522                 }
01523 
01524         c = *(<font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> *) yy_c_buf_p;      <font class="comment">/* cast for 8-bit char's */</font>
01525         *yy_c_buf_p = <font class="charliteral">'\0'</font>;     <font class="comment">/* preserve yytext */</font>
01526         yy_hold_char = *++yy_c_buf_p;
01527 
01528         <font class="keywordflow">if</font> ( c == <font class="charliteral">'\n'</font> )
01529                 ++yylineno;
01530 
01531         <font class="keywordflow">return</font> c;
01532         }
01533 
01534 
01535 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01536 <font class="preprocessor"></font><font class="keywordtype">void</font> yyrestart( FILE *input_file )
01537 <font class="preprocessor">#else</font>
01538 <font class="preprocessor"></font><font class="keywordtype">void</font> yyrestart( input_file )
01539 FILE *input_file;
01540 <font class="preprocessor">#endif</font>
01541 <font class="preprocessor"></font>        {
01542         <font class="keywordflow">if</font> ( ! yy_current_buffer )
01543                 yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
01544 
01545         yy_init_buffer( yy_current_buffer, input_file );
01546         yy_load_buffer_state();
01547         }
01548 
01549 
01550 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01551 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
01552 <font class="preprocessor">#else</font>
01553 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_switch_to_buffer( new_buffer )
01554 YY_BUFFER_STATE new_buffer;
01555 <font class="preprocessor">#endif</font>
01556 <font class="preprocessor"></font>        {
01557         <font class="keywordflow">if</font> ( yy_current_buffer == new_buffer )
01558                 <font class="keywordflow">return</font>;
01559 
01560         <font class="keywordflow">if</font> ( yy_current_buffer )
01561                 {
01562                 <font class="comment">/* Flush out information for old buffer. */</font>
01563                 *yy_c_buf_p = yy_hold_char;
01564                 yy_current_buffer-&gt;yy_buf_pos = yy_c_buf_p;
01565                 yy_current_buffer-&gt;yy_n_chars = yy_n_chars;
01566                 }
01567 
01568         yy_current_buffer = new_buffer;
01569         yy_load_buffer_state();
01570 
01571         <font class="comment">/* We don't actually know whether we did this switch during</font>
01572 <font class="comment">         * EOF (yywrap()) processing, but the only time this flag</font>
01573 <font class="comment">         * is looked at is after yywrap() is called, so it's safe</font>
01574 <font class="comment">         * to go ahead and always set it.</font>
01575 <font class="comment">         */</font>
01576         yy_did_buffer_switch_on_eof = 1;
01577         }
01578 
01579 
01580 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01581 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_load_buffer_state( <font class="keywordtype">void</font> )
01582 <font class="preprocessor">#else</font>
01583 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_load_buffer_state()
01584 <font class="preprocessor">#endif</font>
01585 <font class="preprocessor"></font>        {
01586         yy_n_chars = yy_current_buffer-&gt;yy_n_chars;
01587         yytext_ptr = yy_c_buf_p = yy_current_buffer-&gt;yy_buf_pos;
01588         yyin = yy_current_buffer-&gt;yy_input_file;
01589         yy_hold_char = *yy_c_buf_p;
01590         }
01591 
01592 
01593 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01594 <font class="preprocessor"></font>YY_BUFFER_STATE yy_create_buffer( FILE *file, <font class="keywordtype">int</font> size )
01595 <font class="preprocessor">#else</font>
01596 <font class="preprocessor"></font>YY_BUFFER_STATE yy_create_buffer( file, size )
01597 FILE *file;
01598 <font class="keywordtype">int</font> size;
01599 <font class="preprocessor">#endif</font>
01600 <font class="preprocessor"></font>        {
01601         YY_BUFFER_STATE b;
01602 
01603         b = (YY_BUFFER_STATE) yy_flex_alloc( <font class="keyword">sizeof</font>( <font class="keyword">struct</font> yy_buffer_state ) );
01604         <font class="keywordflow">if</font> ( ! b )
01605                 YY_FATAL_ERROR( <font class="stringliteral">"out of dynamic memory in yy_create_buffer()"</font> );
01606 
01607         b-&gt;yy_buf_size = size;
01608 
01609         <font class="comment">/* yy_ch_buf has to be 2 characters longer than the size given because</font>
01610 <font class="comment">         * we need to put in 2 end-of-buffer characters.</font>
01611 <font class="comment">         */</font>
01612         b-&gt;yy_ch_buf = (<font class="keywordtype">char</font> *) yy_flex_alloc( b-&gt;yy_buf_size + 2 );
01613         <font class="keywordflow">if</font> ( ! b-&gt;yy_ch_buf )
01614                 YY_FATAL_ERROR( <font class="stringliteral">"out of dynamic memory in yy_create_buffer()"</font> );
01615 
01616         b-&gt;yy_is_our_buffer = 1;
01617 
01618         yy_init_buffer( b, file );
01619 
01620         <font class="keywordflow">return</font> b;
01621         }
01622 
01623 
01624 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01625 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_delete_buffer( YY_BUFFER_STATE b )
01626 <font class="preprocessor">#else</font>
01627 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_delete_buffer( b )
01628 YY_BUFFER_STATE b;
01629 <font class="preprocessor">#endif</font>
01630 <font class="preprocessor"></font>        {
01631         <font class="keywordflow">if</font> ( ! b )
01632                 <font class="keywordflow">return</font>;
01633 
01634         <font class="keywordflow">if</font> ( b == yy_current_buffer )
01635                 yy_current_buffer = (YY_BUFFER_STATE) 0;
01636 
01637         <font class="keywordflow">if</font> ( b-&gt;yy_is_our_buffer )
01638                 yy_flex_free( (<font class="keywordtype">void</font> *) b-&gt;yy_ch_buf );
01639 
01640         yy_flex_free( (<font class="keywordtype">void</font> *) b );
01641         }
01642 
01643 
01644 <font class="preprocessor">#ifndef YY_ALWAYS_INTERACTIVE</font>
01645 <font class="preprocessor"></font><font class="preprocessor">#ifndef YY_NEVER_INTERACTIVE</font>
01646 <font class="preprocessor"></font><font class="keyword">extern</font> <font class="keywordtype">int</font> isatty YY_PROTO(( <font class="keywordtype">int</font> ));
01647 <font class="preprocessor">#endif</font>
01648 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
01649 <font class="preprocessor"></font>
01650 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01651 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
01652 <font class="preprocessor">#else</font>
01653 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_init_buffer( b, file )
01654 YY_BUFFER_STATE b;
01655 FILE *file;
01656 <font class="preprocessor">#endif</font>
01657 <font class="preprocessor"></font>
01658 
01659         {
01660         yy_flush_buffer( b );
01661 
01662         b-&gt;yy_input_file = file;
01663         b-&gt;yy_fill_buffer = 1;
01664 
01665 <font class="preprocessor">#if YY_ALWAYS_INTERACTIVE</font>
01666 <font class="preprocessor"></font>        b-&gt;yy_is_interactive = 1;
01667 <font class="preprocessor">#else</font>
01668 <font class="preprocessor"></font><font class="preprocessor">#if YY_NEVER_INTERACTIVE</font>
01669 <font class="preprocessor"></font>        b-&gt;yy_is_interactive = 0;
01670 <font class="preprocessor">#else</font>
01671 <font class="preprocessor"></font>        b-&gt;yy_is_interactive = file ? (isatty( fileno(file) ) &gt; 0) : 0;
01672 <font class="preprocessor">#endif</font>
01673 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
01674 <font class="preprocessor"></font>        }
01675 
01676 
01677 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01678 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_flush_buffer( YY_BUFFER_STATE b )
01679 <font class="preprocessor">#else</font>
01680 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_flush_buffer( b )
01681 YY_BUFFER_STATE b;
01682 <font class="preprocessor">#endif</font>
01683 <font class="preprocessor"></font>
01684         {
01685         <font class="keywordflow">if</font> ( ! b )
01686                 <font class="keywordflow">return</font>;
01687 
01688         b-&gt;yy_n_chars = 0;
01689 
01690         <font class="comment">/* We always need two end-of-buffer characters.  The first causes</font>
01691 <font class="comment">         * a transition to the end-of-buffer state.  The second causes</font>
01692 <font class="comment">         * a jam in that state.</font>
01693 <font class="comment">         */</font>
01694         b-&gt;yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
01695         b-&gt;yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
01696 
01697         b-&gt;yy_buf_pos = &amp;b-&gt;yy_ch_buf[0];
01698 
01699         b-&gt;yy_at_bol = 1;
01700         b-&gt;yy_buffer_status = YY_BUFFER_NEW;
01701 
01702         <font class="keywordflow">if</font> ( b == yy_current_buffer )
01703                 yy_load_buffer_state();
01704         }
01705 
01706 
01707 <font class="preprocessor">#ifndef YY_NO_SCAN_BUFFER</font>
01708 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01709 <font class="preprocessor"></font>YY_BUFFER_STATE yy_scan_buffer( <font class="keywordtype">char</font> *base, yy_size_t size )
01710 <font class="preprocessor">#else</font>
01711 <font class="preprocessor"></font>YY_BUFFER_STATE yy_scan_buffer( base, size )
01712 <font class="keywordtype">char</font> *base;
01713 yy_size_t size;
01714 <font class="preprocessor">#endif</font>
01715 <font class="preprocessor"></font>        {
01716         YY_BUFFER_STATE b;
01717 
01718         <font class="keywordflow">if</font> ( size &lt; 2 ||
01719              base[size-2] != YY_END_OF_BUFFER_CHAR ||
01720              base[size-1] != YY_END_OF_BUFFER_CHAR )
01721                 <font class="comment">/* They forgot to leave room for the EOB's. */</font>
01722                 <font class="keywordflow">return</font> 0;
01723 
01724         b = (YY_BUFFER_STATE) yy_flex_alloc( <font class="keyword">sizeof</font>( <font class="keyword">struct</font> yy_buffer_state ) );
01725         <font class="keywordflow">if</font> ( ! b )
01726                 YY_FATAL_ERROR( <font class="stringliteral">"out of dynamic memory in yy_scan_buffer()"</font> );
01727 
01728         b-&gt;yy_buf_size = size - 2;      <font class="comment">/* "- 2" to take care of EOB's */</font>
01729         b-&gt;yy_buf_pos = b-&gt;yy_ch_buf = base;
01730         b-&gt;yy_is_our_buffer = 0;
01731         b-&gt;yy_input_file = 0;
01732         b-&gt;yy_n_chars = b-&gt;yy_buf_size;
01733         b-&gt;yy_is_interactive = 0;
01734         b-&gt;yy_at_bol = 1;
01735         b-&gt;yy_fill_buffer = 0;
01736         b-&gt;yy_buffer_status = YY_BUFFER_NEW;
01737 
01738         yy_switch_to_buffer( b );
01739 
01740         <font class="keywordflow">return</font> b;
01741         }
01742 <font class="preprocessor">#endif</font>
01743 <font class="preprocessor"></font>
01744 
01745 <font class="preprocessor">#ifndef YY_NO_SCAN_STRING</font>
01746 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01747 <font class="preprocessor"></font>YY_BUFFER_STATE yy_scan_string( yyconst <font class="keywordtype">char</font> *yy_str )
01748 <font class="preprocessor">#else</font>
01749 <font class="preprocessor"></font>YY_BUFFER_STATE yy_scan_string( yy_str )
01750 yyconst <font class="keywordtype">char</font> *yy_str;
01751 <font class="preprocessor">#endif</font>
01752 <font class="preprocessor"></font>        {
01753         <font class="keywordtype">int</font> len;
01754         <font class="keywordflow">for</font> ( len = 0; yy_str[len]; ++len )
01755                 ;
01756 
01757         <font class="keywordflow">return</font> yy_scan_bytes( yy_str, len );
01758         }
01759 <font class="preprocessor">#endif</font>
01760 <font class="preprocessor"></font>
01761 
01762 <font class="preprocessor">#ifndef YY_NO_SCAN_BYTES</font>
01763 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01764 <font class="preprocessor"></font>YY_BUFFER_STATE yy_scan_bytes( yyconst <font class="keywordtype">char</font> *bytes, <font class="keywordtype">int</font> len )
01765 <font class="preprocessor">#else</font>
01766 <font class="preprocessor"></font>YY_BUFFER_STATE yy_scan_bytes( bytes, len )
01767 yyconst <font class="keywordtype">char</font> *bytes;
01768 <font class="keywordtype">int</font> len;
01769 <font class="preprocessor">#endif</font>
01770 <font class="preprocessor"></font>        {
01771         YY_BUFFER_STATE b;
01772         <font class="keywordtype">char</font> *buf;
01773         yy_size_t n;
01774         <font class="keywordtype">int</font> i;
01775 
01776         <font class="comment">/* Get memory for full buffer, including space for trailing EOB's. */</font>
01777         n = len + 2;
01778         buf = (<font class="keywordtype">char</font> *) yy_flex_alloc( n );
01779         <font class="keywordflow">if</font> ( ! buf )
01780                 YY_FATAL_ERROR( <font class="stringliteral">"out of dynamic memory in yy_scan_bytes()"</font> );
01781 
01782         <font class="keywordflow">for</font> ( i = 0; i &lt; len; ++i )
01783                 buf[i] = bytes[i];
01784 
01785         buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
01786 
01787         b = yy_scan_buffer( buf, n );
01788         <font class="keywordflow">if</font> ( ! b )
01789                 YY_FATAL_ERROR( <font class="stringliteral">"bad buffer in yy_scan_bytes()"</font> );
01790 
01791         <font class="comment">/* It's okay to grow etc. this buffer, and we should throw it</font>
01792 <font class="comment">         * away when we're done.</font>
01793 <font class="comment">         */</font>
01794         b-&gt;yy_is_our_buffer = 1;
01795 
01796         <font class="keywordflow">return</font> b;
01797         }
01798 <font class="preprocessor">#endif</font>
01799 <font class="preprocessor"></font>
01800 
01801 <font class="preprocessor">#ifndef YY_NO_PUSH_STATE</font>
01802 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01803 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_push_state( <font class="keywordtype">int</font> new_state )
01804 <font class="preprocessor">#else</font>
01805 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_push_state( new_state )
01806 <font class="keywordtype">int</font> new_state;
01807 <font class="preprocessor">#endif</font>
01808 <font class="preprocessor"></font>        {
01809         <font class="keywordflow">if</font> ( yy_start_stack_ptr &gt;= yy_start_stack_depth )
01810                 {
01811                 yy_size_t new_size;
01812 
01813                 yy_start_stack_depth += YY_START_STACK_INCR;
01814                 new_size = yy_start_stack_depth * <font class="keyword">sizeof</font>( <font class="keywordtype">int</font> );
01815 
01816                 <font class="keywordflow">if</font> ( ! yy_start_stack )
01817                         yy_start_stack = (<font class="keywordtype">int</font> *) yy_flex_alloc( new_size );
01818 
01819                 <font class="keywordflow">else</font>
01820                         yy_start_stack = (<font class="keywordtype">int</font> *) yy_flex_realloc(
01821                                         (<font class="keywordtype">void</font> *) yy_start_stack, new_size );
01822 
01823                 <font class="keywordflow">if</font> ( ! yy_start_stack )
01824                         YY_FATAL_ERROR(
01825                         <font class="stringliteral">"out of memory expanding start-condition stack"</font> );
01826                 }
01827 
01828         yy_start_stack[yy_start_stack_ptr++] = YY_START;
01829 
01830         BEGIN(new_state);
01831         }
01832 <font class="preprocessor">#endif</font>
01833 <font class="preprocessor"></font>
01834 
01835 <font class="preprocessor">#ifndef YY_NO_POP_STATE</font>
01836 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_pop_state()<font class="keyword"></font>
01837 <font class="keyword">        </font>{
01838         <font class="keywordflow">if</font> ( --yy_start_stack_ptr &lt; 0 )
01839                 YY_FATAL_ERROR( <font class="stringliteral">"start-condition stack underflow"</font> );
01840 
01841         BEGIN(yy_start_stack[yy_start_stack_ptr]);
01842         }
01843 <font class="preprocessor">#endif</font>
01844 <font class="preprocessor"></font>
01845 
01846 <font class="preprocessor">#ifndef YY_NO_TOP_STATE</font>
01847 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yy_top_state()<font class="keyword"></font>
01848 <font class="keyword">        </font>{
01849         <font class="keywordflow">return</font> yy_start_stack[yy_start_stack_ptr - 1];
01850         }
01851 <font class="preprocessor">#endif</font>
01852 <font class="preprocessor"></font>
01853 <font class="preprocessor">#ifndef YY_EXIT_FAILURE</font>
01854 <font class="preprocessor"></font><font class="preprocessor">#define YY_EXIT_FAILURE 2</font>
01855 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
01856 <font class="preprocessor"></font>
01857 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01858 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_fatal_error( yyconst <font class="keywordtype">char</font> msg[] )
01859 <font class="preprocessor">#else</font>
01860 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_fatal_error( msg )
01861 <font class="keywordtype">char</font> msg[];
01862 <font class="preprocessor">#endif</font>
01863 <font class="preprocessor"></font>        {
01864         (<font class="keywordtype">void</font>) fprintf( stderr, <font class="stringliteral">"%s\n"</font>, msg );
01865         exit( YY_EXIT_FAILURE );
01866         }
01867 
01868 
01869 
01870 <font class="comment">/* Redefine yyless() so it works in section 3 code. */</font>
01871 
01872 <font class="preprocessor">#undef yyless</font>
01873 <font class="preprocessor"></font><font class="preprocessor">#define yyless(n) \</font>
01874 <font class="preprocessor">        do \</font>
01875 <font class="preprocessor">                { \</font>
01876 <font class="preprocessor">                </font><font class="comment">/* Undo effects of setting up yytext. */</font> \
01877                 yytext[yyleng] = yy_hold_char; \
01878                 yy_c_buf_p = yytext + n; \
01879                 yy_hold_char = *yy_c_buf_p; \
01880                 *yy_c_buf_p = '\0'; \
01881                 yyleng = n; \
01882                 } \
01883         while ( 0 )
01884 
01885 
01886 <font class="comment">/* Internal utility routines. */</font>
01887 
01888 <font class="preprocessor">#ifndef yytext_ptr</font>
01889 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01890 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_flex_strncpy( <font class="keywordtype">char</font> *s1, yyconst <font class="keywordtype">char</font> *s2, <font class="keywordtype">int</font> n )
01891 <font class="preprocessor">#else</font>
01892 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_flex_strncpy( s1, s2, n )
01893 <font class="keywordtype">char</font> *s1;
01894 yyconst <font class="keywordtype">char</font> *s2;
01895 <font class="keywordtype">int</font> n;
01896 <font class="preprocessor">#endif</font>
01897 <font class="preprocessor"></font>        {
01898         <font class="keyword">register</font> <font class="keywordtype">int</font> i;
01899         <font class="keywordflow">for</font> ( i = 0; i &lt; n; ++i )
01900                 s1[i] = s2[i];
01901         }
01902 <font class="preprocessor">#endif</font>
01903 <font class="preprocessor"></font>
01904 <font class="preprocessor">#ifdef YY_NEED_STRLEN</font>
01905 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01906 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yy_flex_strlen( yyconst <font class="keywordtype">char</font> *s )
01907 <font class="preprocessor">#else</font>
01908 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yy_flex_strlen( s )
01909 yyconst <font class="keywordtype">char</font> *s;
01910 <font class="preprocessor">#endif</font>
01911 <font class="preprocessor"></font>        {
01912         <font class="keyword">register</font> <font class="keywordtype">int</font> n;
01913         <font class="keywordflow">for</font> ( n = 0; s[n]; ++n )
01914                 ;
01915 
01916         <font class="keywordflow">return</font> n;
01917         }
01918 <font class="preprocessor">#endif</font>
01919 <font class="preprocessor"></font>
01920 
01921 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01922 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> *yy_flex_alloc( yy_size_t size )
01923 <font class="preprocessor">#else</font>
01924 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> *yy_flex_alloc( size )
01925 yy_size_t size;
01926 <font class="preprocessor">#endif</font>
01927 <font class="preprocessor"></font>        {
01928         <font class="keywordflow">return</font> (<font class="keywordtype">void</font> *) malloc( size );
01929         }
01930 
01931 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01932 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> *yy_flex_realloc( <font class="keywordtype">void</font> *ptr, yy_size_t size )
01933 <font class="preprocessor">#else</font>
01934 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> *yy_flex_realloc( ptr, size )
01935 <font class="keywordtype">void</font> *ptr;
01936 yy_size_t size;
01937 <font class="preprocessor">#endif</font>
01938 <font class="preprocessor"></font>        {
01939         <font class="comment">/* The cast to (char *) in the following accommodates both</font>
01940 <font class="comment">         * implementations that use char* generic pointers, and those</font>
01941 <font class="comment">         * that use void* generic pointers.  It works with the latter</font>
01942 <font class="comment">         * because both ANSI C and C++ allow castless assignment from</font>
01943 <font class="comment">         * any pointer type to void*, and deal with argument conversions</font>
01944 <font class="comment">         * as though doing an assignment.</font>
01945 <font class="comment">         */</font>
01946         <font class="keywordflow">return</font> (<font class="keywordtype">void</font> *) realloc( (<font class="keywordtype">char</font> *) ptr, size );
01947         }
01948 
01949 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
01950 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_flex_free( <font class="keywordtype">void</font> *ptr )
01951 <font class="preprocessor">#else</font>
01952 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_flex_free( ptr )
01953 <font class="keywordtype">void</font> *ptr;
01954 <font class="preprocessor">#endif</font>
01955 <font class="preprocessor"></font>        {
01956         free( ptr );
01957         }
01958 
01959 <font class="preprocessor">#if YY_MAIN</font>
01960 <font class="preprocessor"></font><font class="keywordtype">int</font> main()<font class="keyword"></font>
01961 <font class="keyword">        </font>{
01962         yylex();
01963         <font class="keywordflow">return</font> 0;
01964         }
01965 <font class="preprocessor">#endif</font>
01966 <font class="preprocessor"></font><font class="preprocessor">#line 139 "ExpSpec.lex"</font>
01967 <font class="preprocessor"></font>
01968 
01969 <font class="keywordtype">char</font>* trimdelims(<font class="keyword">const</font> <font class="keywordtype">char</font>* t)<font class="keyword"> </font>{
01970   <font class="keywordtype">int</font> l = strlen(t);
01971   <font class="keywordtype">char</font>* s = <font class="keyword">new</font> <font class="keywordtype">char</font>[l];
01972   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; l-2; i++)
01973     s[i] = t[i+1];
01974   s[l-2] = <font class="charliteral">'\0'</font>;
01975   <font class="keywordflow">return</font> s;
01976 }
01977 
01978 <font class="keywordtype">char</font>* copy(<font class="keyword">const</font> <font class="keywordtype">char</font>* t)<font class="keyword"> </font>{
01979   <font class="keywordtype">int</font> l = strlen(t);
01980   <font class="keywordtype">char</font>* s = <font class="keyword">new</font> <font class="keywordtype">char</font>[l+1];
01981   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; l; i++)
01982     s[i] = t[i];
01983   s[l] = <font class="charliteral">'\0'</font>;
01984   <font class="keywordflow">return</font> s;
01985 }
</div></pre>      </td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><hr>
        <span class="mark">Go to:</span> the <a href="index.html">Main Page</a> of the documentation.
      </td>
    </tr>
  </tbody>
</table>
</body>
</html>
